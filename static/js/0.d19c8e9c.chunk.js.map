{"version":3,"sources":["../../../../../src/.internal/core/utils/EventDispatcher.ts","../../../../../src/.internal/core/utils/String.ts","../../../../../src/.internal/core/utils/Cache.ts","../node_modules/tslib/tslib.es6.js","../../../../../src/.internal/core/Registry.ts","../../../../../src/.internal/core/utils/Type.ts","../../../../../src/.internal/core/utils/Math.ts","../../../../../src/.internal/core/utils/Array.ts","../../../../../src/.internal/core/utils/Disposer.ts","../../../../../src/.internal/core/utils/Iterator.ts","../../../../../src/.internal/core/utils/Percent.ts","../../../../../src/.internal/core/utils/Object.ts","../../../../../src/.internal/core/utils/Dictionary.ts","../../../../../src/.internal/core/utils/AsyncPending.ts"],"names":["this","_listeners","_killed","_disabled","_iterating","_enabled","_disposed","isDisposed","dispose","a","x","disposer","hasListeners","length","hasListenersByType","type","enable","disable","enableType","disableType","amount","_removeListener","listener","index","indexOf","Error","splice","push","_removeExistingListener","once","callback","context","_eachListener","info","isEnabled","has","_shouldDispatch","count","fn","killed","dispatchImmediately","event","dispatch","_on","shouldClone","onAll","call","on","off","copyFrom","source","target","EventDispatcher","order","b","repeat","string","Array","join","random","chars","res","choice","i","charAt","Math","floor","_storage","ttl","set","owner","key","value","ownerStorage","insertKeyIfEmpty","item","Date","getTime","setKey","get","hasKey","getKey","cacheItem","touched","expired","removeKey","clear","cache","Cache","extendStatics","d","Object","setPrototypeOf","__proto__","p","hasOwnProperty","__extends","__","constructor","prototype","create","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","Symbol","iterator","n","v","op","TypeError","pop","__values","o","s","m","__read","r","ar","error","__spread","arguments","concat","events","themes","loadedThemes","_uidCount","registeredClasses","_placeholders","invalidSprites","invalidDatas","invalidRawDatas","invalidDataItems","invalidDataRange","invalidPositions","invalidLayouts","baseSprites","baseSpritesByUid","queue","uid","getUniqueId","noBase","_map","setCache","getCache","eventType","data","getPlaceholder","addToInvalidComponents","component","baseId","removeFromInvalidComponents","addToInvalidSprites","sprite","removeFromInvalidSprites","addToInvalidPositions","removeFromInvalidPositions","addToInvalidLayouts","removeFromInvalidLayouts","registry","Registry","is","object","name","isNaN","Number","getType","toString","getDefault","optional","checkString","checkBoolean","checkNumber","checkObject","checkArray","isArray","checkDate","castString","castNumber","number","JSON","stringify","toBoolean","toNumber","hasValue","isNumber","converted","isString","replace","toText","isObject","toNumberOrPercent","getValue","getValueDefault","defaultValue","isDate","PI","HALFPI","RADIANS","DEGREES","toNumberRange","min","max","fitToRange","round","precision","rounded","pow","ceil","stretch","from","to","minValue","maxValue","temp","sin","tan","cos","left","right","closest","values","referenceValue","reduce","prev","curr","abs","intersect","range1","range2","start1","start","start2","end1","end","end2","invertRange","range","intersection","startMax","endMin","getDistance","point1","point2","sqrt","getHorizontalDistance","getVerticalDistance","getCubicCurveDistance","controlPointA","controlPointB","stepCount","distance","prevPoint","point","getPointOnCubicCurve","getScale","startPoint1","startPoint2","initialDistance","currentDistance","getMidPoint","position","getRotation","diff","getAngle","diffX","diffY","angle","atan2","normalizeAngle","getCenterShift","center","getBBox","points","bottom","width","height","getCommonRectangle","rectangles","minX","minY","maxX","maxY","rectangle","getPointOnQuadraticCurve","pointA","pointB","controlPoint","mt1","mt2","mt3","getCubicControlPointA","p0","p1","p2","p3","tensionX","tensionY","adjustTension","getCubicControlPointB","tension","fitAngleToRange","startAngle","endAngle","getArcRect","radius","MAX_VALUE","bpoints","getArcPoint","fromAngle","toAngle","pt","arc","isInRectangle","getLineIntersection","pointA1","pointA2","pointB1","pointB2","array","any","test","map","output","each","eachReverse","eachContinue","shiftLeft","last","undefined","first","insert","element","setIndex","remove","pushAll","input","found","move","toIndex","removeIndex","insertIndex","add","unshift","ind","toArray","copy","slice","getSortedIndex","ordering","pivot","findIndex","matches","find","shuffle","temporaryValue","randomIndex","currentIndex","_dispose","disposers","Disposer","_disposer","_value","reset","_counter","increment","fromArray","iter","sum","sort","filter","go","push2","args","flatten","indexed","findMap","contains","foldl","init","min2","max2","separator","list","createNewItems","_create","_listCopy","getFirst","returnItem","getLast","removeItem","percent","Percent","isPercent","entries","keys","keysOrdered","eachOrdered","ord","assign","merge","object1","object2","copyProperties","softCopyProperties","forceCopyProperties","copyAllProperties","dict","oldValue","_dictionary","insertKey","newValue","updateKey","ifEmpty","sortedIterator","template","_template","isTemplate","clone","Dictionary","pendingFrame","nextQueue","readQueue","writeQueue","idleQueue","raf","requestAnimationFrame","setTimeout","frameLoop","now","pendFrame","nextFrame","readFrame","writeFrame","whenIdle","triggerIdle","shift"],"mappings":"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","file":"static/js/0.d19c8e9c.chunk.js","sourcesContent":["/**\r\n * Event Dispatcher module is used for registering listeners and dispatching\r\n * events across amCharts system.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Disposer, IDisposer } from \"./Disposer\";\r\nimport * as $array from \"./Array\";\r\nimport * as $async from \"./AsyncPending\";\r\nimport * as $type from \"./Type\";\r\n\r\n/**\r\n * Defines a universal type for the event object.\r\n */\r\nexport type AMEvent<Target, T> = {\r\n\t[K in keyof T]: { type: K, target: Target } & T[K];\r\n};\r\n\r\n/**\r\n * A universal interface for event listeners.\r\n */\r\nexport interface EventListener<T> {\r\n\tkilled: boolean;\r\n\tonce: boolean;\r\n\ttype: any;\r\n\tcallback: any;\r\n\tcontext: any;\r\n\tshouldClone: boolean;\r\n\tdispatch: any;\r\n\tdisposer: IDisposer;\r\n}\r\n\r\n/*export interface IEventDispatcher<T> {\r\n\tisDisposed(): boolean;\r\n\tdispose(): void;\r\n\thasListeners(): boolean;\r\n\tenable(): void;\r\n\tdisable(): void;\r\n\tenableType<Key extends keyof T>(type: Key): void;\r\n\tdisableType<Key extends keyof T>(type: Key, amount?: number): void;\r\n\tisEnabled<Key extends keyof T>(type: Key): boolean;\r\n\thas<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean;\r\n\tdispatchImmediately<Key extends keyof T>(type: Key, event: T[Key]): void;\r\n\tdispatch<Key extends keyof T>(type: Key, event: T[Key]): void;\r\n\tonAll<C, Key extends keyof T>(callback: (this: C, type: Key, event: T[Key]) => void, context?: C): IDisposer;\r\n\ton<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;\r\n\tonce<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;\r\n\toff<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;\r\n\toff<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;\r\n\tcopyFrom(source: this): void;\r\n}*/\r\n\r\n/**\r\n * Universal Event Dispatcher.\r\n *\r\n * @important\r\n */\r\nexport class EventDispatcher<T> implements IDisposer {\r\n\r\n\tprotected _listeners: Array<EventListener<T>>;\r\n\tprotected _killed: Array<EventListener<T>>;\r\n\tprotected _disabled: { [key in keyof T]?: number };\r\n\tprotected _iterating: number;\r\n\tprotected _enabled: boolean;\r\n\tprotected _disposed: boolean;\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tthis._listeners = [];\r\n\t\tthis._killed = [];\r\n\t\tthis._disabled = {};\r\n\t\tthis._iterating = 0;\r\n\t\tthis._enabled = true;\r\n\t\tthis._disposed = false;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns if this object has been already disposed.\r\n\t *\r\n\t * @return Disposed?\r\n\t */\r\n\tpublic isDisposed(): boolean {\r\n\t\treturn this._disposed;\r\n\t}\r\n\r\n\t/**\r\n\t * Dispose (destroy) this object.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tif (!this._disposed) {\r\n\t\t\tthis._disposed = true;\r\n\r\n\t\t\tconst a = this._listeners;\r\n\r\n\t\t\tthis._iterating = 1;\r\n\t\t\tthis._listeners = <any>null;\r\n\t\t\tthis._disabled = <any>null;\r\n\r\n\t\t\ttry {\r\n\t\t\t\t$array.each(a, (x) => {\r\n\t\t\t\t\tx.disposer.dispose();\r\n\t\t\t\t});\r\n\r\n\t\t\t} finally {\r\n\t\t\t\tthis._killed = <any>null;\r\n\t\t\t\tthis._iterating = <any>null;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this particular event dispatcher has any listeners set.\r\n\t *\r\n\t * @return Has listeners?\r\n\t */\r\n\tpublic hasListeners(): boolean {\r\n\t\treturn this._listeners.length !== 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this particular event dispatcher has any particular listeners set.\r\n\t *\r\n\t * @return Has particular event listeners?\r\n\t */\r\n\tpublic hasListenersByType<Key extends keyof T>(type: Key): boolean {\r\n\t\treturn $array.any(this._listeners, (x) => (x.type === null || x.type === type) && !x.killed);\r\n\t}\r\n\r\n\t/**\r\n\t * Enable dispatching of events if they were previously disabled by\r\n\t * `disable()`.\r\n\t */\r\n\tpublic enable(): void {\r\n\t\tthis._enabled = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Disable dispatching of events until re-enabled by `enable()`.\r\n\t */\r\n\tpublic disable(): void {\r\n\t\tthis._enabled = false;\r\n\t}\r\n\r\n\t/**\r\n\t * Enable dispatching particular event, if it was disabled before by\r\n\t * `disableType()`.\r\n\t *\r\n\t * @param type Event type\r\n\t */\r\n\tpublic enableType<Key extends keyof T>(type: Key): void {\r\n\t\tdelete this._disabled[type];\r\n\t}\r\n\r\n\t/**\r\n\t * Disable dispatching of events for a certain event type.\r\n\t *\r\n\t * Optionally, can set how many dispatches to skip before automatically\r\n\t * re-enabling the dispatching.\r\n\t *\r\n\t * @param type    Event type\r\n\t * @param amount  Number of event dispatches to skip\r\n\t */\r\n\tpublic disableType<Key extends keyof T>(type: Key, amount: number = Infinity): void {\r\n\t\tthis._disabled[type] = amount;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes listener from dispatcher.\r\n\t *\r\n\t * Will throw an exception if such listener does not exists.\r\n\t *\r\n\t * @param listener Listener to remove\r\n\t */\r\n\tprotected _removeListener(listener: EventListener<T>): void {\r\n\t\tif (this._iterating === 0) {\r\n\t\t\tconst index = this._listeners.indexOf(listener);\r\n\r\n\t\t\tif (index === -1) {\r\n\t\t\t\tthrow new Error(\"Invalid state: could not remove listener\");\r\n\t\t\t}\r\n\r\n\t\t\tthis._listeners.splice(index, 1);\r\n\r\n\t\t} else {\r\n\t\t\tthis._killed.push(listener);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Removes existing listener by certain parameters.\r\n\t *\r\n\t * @param once         Listener's once setting\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t */\r\n\tprotected _removeExistingListener<A, B, Key extends keyof T>(once: boolean, type: Key | null, callback?: A, context?: B): void {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tthis._eachListener((info) => {\r\n\t\t\tif (info.once === once && // TODO is this correct ?\r\n\t\t\t\tinfo.type === type &&\r\n\t\t\t\t(callback == null || info.callback === callback) &&\r\n\t\t\t\tinfo.context === context) {\r\n\t\t\t\tinfo.disposer.dispose();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if dispatching for particular event type is enabled.\r\n\t *\r\n\t * @param type  Event type\r\n\t * @return Enabled?\r\n\t */\r\n\tpublic isEnabled<Key extends keyof T>(type: Key): boolean {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\t// TODO is this check correct ?\r\n\t\treturn this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] == null;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if there's already a listener with specific parameters.\r\n\t *\r\n\t * @param type      Listener's type\r\n\t * @param callback  Callback function\r\n\t * @param context   Callback context\r\n\t * @return Has listener?\r\n\t */\r\n\tpublic has<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean {\r\n\t\tconst index = $array.findIndex(this._listeners, (info) => {\r\n\t\t\treturn info.once !== true && // Ignoring \"once\" listeners\r\n\t\t\t\tinfo.type === type &&\r\n\t\t\t\t(callback == null || info.callback === callback) &&\r\n\t\t\t\tinfo.context === context;\r\n\t\t});\r\n\r\n\t\treturn index !== -1;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether event of the particular type should be dispatched.\r\n\t *\r\n\t * @param type  Event type\r\n\t * @return Dispatch?\r\n\t */\r\n\tprotected _shouldDispatch<Key extends keyof T>(type: Key): boolean {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tconst count = this._disabled[type];\r\n\r\n\t\tif (!$type.isNumber(count)) {\r\n\t\t\treturn this._enabled;\r\n\r\n\t\t} else {\r\n\t\t\tif (count <= 1) {\r\n\t\t\t\tdelete this._disabled[type];\r\n\r\n\t\t\t} else {\r\n\t\t\t\t--this._disabled[type];\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [_eachListener description]\r\n\t *\r\n\t * All of this extra code is needed when a listener is removed while iterating\r\n\t *\r\n\t * @todo Description\r\n\t * @param fn [description]\r\n\t */\r\n\tprotected _eachListener(fn: (listener: EventListener<T>) => void): void {\r\n\t\t++this._iterating;\r\n\r\n\t\ttry {\r\n\t\t\t$array.each(this._listeners, fn);\r\n\r\n\t\t} finally {\r\n\t\t\t--this._iterating;\r\n\r\n\t\t\t// TODO should this be inside or outside the finally ?\r\n\t\t\tif (this._iterating === 0 && this._killed.length !== 0) {\r\n\t\t\t\t// Remove killed listeners\r\n\t\t\t\t$array.each(this._killed, (killed) => {\r\n\t\t\t\t\tthis._removeListener(killed);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis._killed.length = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Dispatches an event immediately without waiting for next cycle.\r\n\t *\r\n\t * @param type   Event type\r\n\t * @param event  Event object\r\n\t * @todo automatically add in type and target properties if they are missing\r\n\t */\r\n\tpublic dispatchImmediately<Key extends keyof T>(type: Key, event: T[Key]): void {\r\n\t\tif (this._shouldDispatch(type)) {\r\n\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\r\n\t\t\t// TODO if the function throws, maybe it should keep going ?\r\n\t\t\tthis._eachListener((listener) => {\r\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\r\n\t\t\t\t\tlistener.dispatch(type, event);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Shelves the event to be dispatched within next update cycle.\r\n\t *\r\n\t * @param type   Event type\r\n\t * @param event  Event object\r\n\t * @todo automatically add in type and target properties if they are missing\r\n\t */\r\n\tpublic dispatch<Key extends keyof T>(type: Key, event: T[Key]): void {\r\n\t\tif (this._shouldDispatch(type)) {\r\n\t\t\tthis._eachListener((listener) => {\r\n\t\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\r\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\r\n\t\t\t\t\t// TODO if the function throws, maybe it should keep going ?\r\n\t\t\t\t\t// TODO dispatch during the update cycle, rather than using whenIdle\r\n\t\t\t\t\t$async.whenIdle(() => {\r\n\t\t\t\t\t\tif (!listener.killed) {\r\n\t\t\t\t\t\t\tlistener.dispatch(type, event);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Creates, catalogs and returns an [[EventListener]].\r\n\t *\r\n\t * Event listener can be disposed.\r\n\t *\r\n\t * @param once         Listener's once setting\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @param dispatch\r\n\t * @returns An event listener\r\n\t */\r\n\tprotected _on<A, B, Key extends keyof T>(once: boolean, type: Key | null, callback: A, context: B, shouldClone: boolean, dispatch: (type: Key, event: T[Key]) => void): EventListener<T> {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tthis._removeExistingListener(once, type, callback, context);\r\n\r\n\t\tconst info: EventListener<T> = {\r\n\t\t\ttype: type,\r\n\t\t\tcallback: callback,\r\n\t\t\tcontext: context,\r\n\t\t\tshouldClone: shouldClone,\r\n\t\t\tdispatch: <any>dispatch,\r\n\t\t\tkilled: false,\r\n\t\t\tonce: once,\r\n\t\t\tdisposer: new Disposer(() => {\r\n\t\t\t\tinfo.killed = true;\r\n\t\t\t\tthis._removeListener(info);\r\n\t\t\t})\r\n\t\t};\r\n\r\n\t\tthis._listeners.push(info);\r\n\r\n\t\treturn info;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an event listener to be invoked on **any** event.\r\n\t *\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @returns A disposable event listener\r\n\t * @todo what if `listen` is called on the same function twice ?\r\n\t */\r\n\tpublic onAll<C, Key extends keyof T>(callback: (this: C, type: Key, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\r\n\t\treturn this._on(false, null, callback, context, shouldClone, (type, event) => callback.call(context, type, event)).disposer;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an event listener to be invoked on a specific event type.\r\n\t *\r\n\t * ```TypeScript\r\n\t * series.events.on(\"hidden\", (ev) => {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * series.events.on(\"hidden\", function(ev) {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"series\": [{\r\n\t *     // ...\r\n\t *     \"events\": {\r\n\t *     \t\"hidden\": function(ev) {\r\n\t *     \t  console.log(\"Series hidden: \" + ev.target.name);\r\n\t *     \t}\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * The above will invoke our custom event handler whenever series we put\r\n\t * event on is hidden.\r\n\t *\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @returns A disposable event listener\r\n\t * @todo what if `listen` is called on the same function twice ?\r\n\t */\r\n\tpublic on<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\r\n\t\treturn this._on(false, type, callback, context, shouldClone, (type, event) => callback.call(context, event)).disposer;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an event listener to be invoked on a specific event type once.\r\n\t *\r\n\t * Once the event listener is invoked, it is automatically disposed.\r\n\t *\r\n\t * ```TypeScript\r\n\t * series.events.on(\"hidden\", (ev) => {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * series.events.on(\"hidden\", function(ev) {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"series\": [{\r\n\t *     // ...\r\n\t *     \"events\": {\r\n\t *     \t\"hidden\": function(ev) {\r\n\t *     \t  console.log(\"Series hidden: \" + ev.target.name);\r\n\t *     \t}\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * The above will invoke our custom event handler the first time series we\r\n\t * put event on is hidden.\r\n\t *\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @returns A disposable event listener\r\n\t * @todo what if `listen` is called on the same function twice ?\r\n\t */\r\n\tpublic once<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\r\n\t\tconst x = this._on(true, type, callback, context, shouldClone, (type, event) => {\r\n\t\t\tx.disposer.dispose();\r\n\t\t\tcallback.call(context, event)\r\n\t\t});\r\n\r\n\t\t// TODO maybe this should return a different Disposer ?\r\n\t\treturn x.disposer;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the event listener with specific parameters.\r\n\t *\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t */\r\n\tpublic off<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): void {\r\n\t\tthis._removeExistingListener(false, type, callback, context);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Copies all dispatcher parameters, including listeners, from another event\r\n\t * dispatcher.\r\n\t *\r\n\t * @param source Source event dispatcher\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tif (source === this) {\r\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\r\n\t\t}\r\n\r\n\t\t$array.each(source._listeners, (x) => {\r\n\t\t\t// TODO is this correct ?\r\n\t\t\tif (!x.killed && x.shouldClone) {\r\n\t\t\t\tif (x.type === null) {\r\n\t\t\t\t\tthis.onAll(x.callback, x.context);\r\n\r\n\t\t\t\t} else if (x.once) {\r\n\t\t\t\t\tthis.once(x.type, x.callback, x.context);\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.on(x.type, x.callback, x.context);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * A version of the [[EventDispatcher]] that dispatches events for a specific\r\n * target object.\r\n *\r\n * @important\r\n */\r\nexport class TargetedEventDispatcher<Target, T> extends EventDispatcher<T> {\r\n\r\n\t/**\r\n\t * A target object which is originating events using this dispatcher.\r\n\t */\r\n\tpublic target: Target;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t *\r\n\t * @param target Event dispatcher target\r\n\t */\r\n\tconstructor(target: Target) {\r\n\t\tsuper();\r\n\t\tthis.target = target;\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all dispatcher parameters, including listeners, from another event\r\n\t * dispatcher.\r\n\t *\r\n\t * @param source Source event dispatcher\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tif (source === this) {\r\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\r\n\t\t}\r\n\r\n\t\t$array.each(source._listeners, (x) => {\r\n\t\t\t// TODO very hacky\r\n\t\t\tif (x.context === source.target) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// TODO is this correct ?\r\n\t\t\tif (!x.killed && x.shouldClone) {\r\n\t\t\t\tif (x.type === null) {\r\n\t\t\t\t\tthis.onAll(x.callback, x.context);\r\n\r\n\t\t\t\t} else if (x.once) {\r\n\t\t\t\t\tthis.once(x.type, x.callback, x.context);\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.on(x.type, x.callback, x.context);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n}\r\n","/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\nimport { Ordering } from \"./Order\";\n\n\n/**\n * ============================================================================\n * COMPARING FUNCTIONS\n * ============================================================================\n * @hidden\n */\n\n/**\n * Comparing function used for ordering.\n *\n * @ignore Exclude from docs\n * @todo Use localeCompare\n * @param a  Item 1\n * @param b  Item 2\n * @return Result\n */\nexport function order(a: string, b: string): Ordering {\n\tif (a === b) {\n\t\treturn 0;\n\n\t} else if (a < b) {\n\t\treturn -1;\n\n\t} else {\n\t\treturn 1;\n\t}\n}\n\n\n/**\n * ============================================================================\n * OTHER FUNCTIONS\n * ============================================================================\n * @hidden\n */\n\n/**\n * Repeats a `string` number of times as set in `amount`.\n *\n * @ignore Exclude from docs\n * @todo Make this faster\n * @param string  Source string\n * @param amount  Number of times to repeat string\n * @return New string\n */\nexport function repeat(string: string, amount: number): string {\n\treturn new Array(amount + 1).join(string);\n}\n\n/**\n * Generates a random string `characters` length.\n *\n * @param chars  Number of characters\n * @return Random string\n */\nexport function random(chars: number): string {\n\tlet res = \"\";\n\tlet choice = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\tfor (let i = 0; i < chars; i++) {\n\t\tres += choice.charAt(Math.floor(Math.random() * choice.length));\n\t}\n\treturn res;\n}\n","/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Dictionary } from \"./Dictionary\";\r\nimport * as $type from \"./Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines an interface for cache items.\r\n */\r\ninterface CacheItem<A> {\r\n\r\n\t/**\r\n\t * A timestamp of when the item was created/updated.\r\n\t */\r\n\t\"touched\": number,\r\n\r\n\t/**\r\n\t * TTL (time to live) in milliseconds.\r\n\t */\r\n\t\"ttl\"?: number,\r\n\r\n\t/**\r\n\t * Cached value.\r\n\t */\r\n\t\"value\": A,\r\n\r\n\t/**\r\n\t * Is this item expired?\r\n\t *\r\n\t * @todo a system process that would check chace element TTLs and expire them\r\n\t */\r\n\t\"expired\"?: boolean\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Represents object cache.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Better storage\r\n * @todo TTL logging\r\n * @todo Garbage collector\r\n */\r\nexport class Cache<A> {\r\n\r\n\t/**\r\n\t * Storage for cache items.\r\n\t */\r\n\tprivate _storage = new Dictionary<string, Dictionary<string, CacheItem<A>>>();\r\n\r\n\t/**\r\n\t * Default TTL in milliseconds.\r\n\t */\r\n\tpublic ttl: number = 1000;\r\n\r\n\t/**\r\n\t * Caches or updates cached value, resets TTL.\r\n\t *\r\n\t * If `ttl` is set to zero, item will never expire.\r\n\t *\r\n\t * @param owner  An id of the object that owns this cache\r\n\t * @param key    Index key\r\n\t * @param value  Value\r\n\t * @param ttl    TTL of the cache to live in milliseconds\r\n\t */\r\n\tpublic set(owner: string, key: string, value: A, ttl?: number): void {\r\n\r\n\t\t// Create if storage does not exist for this owner\r\n\t\tlet ownerStorage = this._storage.insertKeyIfEmpty(owner, () => new Dictionary<string, CacheItem<A>>());\r\n\r\n\t\t// Create cache item\r\n\t\tlet item: CacheItem<A> = {\r\n\t\t\t\"touched\": new Date().getTime(),\r\n\t\t\t\"ttl\": $type.isNumber(ttl) ? ttl : this.ttl,\r\n\t\t\t\"value\": value\r\n\t\t};\r\n\r\n\t\t// Set\r\n\t\townerStorage.setKey(key, item);\r\n\t}\r\n\r\n\t/**\r\n\t * Rerturns cached item, respecting TTL.\r\n\t *\r\n\t * @param owner  An id of the object that owns this cache\r\n\t * @param key    Index key\r\n\t * @param value  Value to return if cache not available\r\n\t * @return Value, or `undefined` if not set\r\n\t */\r\n\tpublic get(owner: string, key: string, value: any = undefined): $type.Optional<A> {\r\n\t\t// \t\t || ypeof this._storage[owner][key] === \"undefined\" || this._storage[owner][key].expired === true) {\r\n\t\tif (this._storage.hasKey(owner)) {\r\n\t\t\tlet ownerStorage = <Dictionary<string, CacheItem<A>>>this._storage.getKey(owner);\r\n\r\n\t\t\tif (ownerStorage.hasKey(key)) {\r\n\t\t\t\tlet cacheItem: CacheItem<A> = <CacheItem<A>>ownerStorage.getKey(key);\r\n\t\t\t\tif (cacheItem.ttl && ((cacheItem.touched + cacheItem.ttl) < new Date().getTime())) {\r\n\t\t\t\t\tcacheItem.expired = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (cacheItem.expired) {\r\n\t\t\t\t\townerStorage.removeKey(key);\r\n\t\t\t\t\treturn value;\r\n\t\t\t\t}\r\n\t\t\t\treturn cacheItem.value;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn value;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Clears cache for specific owner or everything.\r\n\t *\r\n\t * @param owner Owner to clear cache for\r\n\t */\r\n\tpublic clear(owner?: string): void {\r\n\t\tif (owner) {\r\n\t\t\tthis._storage.removeKey(owner);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis._storage.clear();\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * ============================================================================\r\n * GLOBAL INSTANCE\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A global instance of cache. Use this instance to cache any values.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport let cache: Cache<any> = new Cache();\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { ITheme } from \"../themes/ITheme\";\r\nimport { EventDispatcher, AMEvent } from \"./utils/EventDispatcher\";\r\nimport { Dictionary } from \"./utils/Dictionary\";\r\nimport { Sprite } from \"./Sprite\";\r\nimport { Container } from \"./Container\";\r\nimport { Component } from \"./Component\";\r\nimport { cache } from \"./utils/Cache\";\r\nimport * as $type from \"./utils/Type\";\r\nimport * as $string from \"./utils/String\";\r\nimport * as $array from \"./utils/Array\";\r\n\r\n\r\n/**\r\n * Define events available for [[Registry]]\r\n */\r\nexport interface IRegistryEvents {\r\n\r\n\t/**\r\n\t * Invoked when update cycle starts. Before invalid elements are re-validated.\r\n\t */\r\n\tenterframe: {};\r\n\r\n\t/**\r\n\t * Invoked when udpate cycle ends. After invalid elements have been\r\n\t * re-validated.\r\n\t */\r\n\texitframe: {};\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Registry is used to store miscellaneous system-wide information, like ids,\r\n * maps, themes, and registered classes.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport class Registry {\r\n\r\n\t/**\r\n\t * Unique ID of the object.\r\n\t */\r\n\tpublic uid: string;\r\n\r\n\t/**\r\n\t * Event dispacther.\r\n\t */\r\n\tpublic events: EventDispatcher<AMEvent<Registry, IRegistryEvents>> = new EventDispatcher();\r\n\r\n\t/**\r\n\t * Holds a universal mapping collection, so that elements and their children\r\n\t * can create and look up all kinds of relations between id and object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected _map: $type.Optional<Dictionary<string, any>>;\r\n\r\n\t/**\r\n\t * All currently applied themes. All new chart instances created will\r\n\t * automatically inherit and retain System's themes.\r\n\t */\r\n\tpublic themes: ITheme[] = [];\r\n\r\n\t/**\r\n\t * List of all loaded available themes.\r\n\t *\r\n\t * Whenever a theme loads, it registers itself in System's `loadedThemes`\r\n\t * collection.\r\n\t */\r\n\tpublic loadedThemes: { [index: string]: ITheme } = {};\r\n\r\n\t/**\r\n\t * An indeternal counter used to generate unique IDs.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected _uidCount: number = 0;\r\n\r\n\t/**\r\n\t * Keeps register of class references so that they can be instnatiated using\r\n\t * string key.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic registeredClasses: { [index: string]: any } = {};\r\n\r\n\t/**\r\n\t * Holds all generated placeholders.\r\n\t */\r\n\tprotected _placeholders: { [index: string]: string } = {};\r\n\r\n\t/**\r\n\t * A list of invalid(ated) [[Sprite]] objects that need to be re-validated\r\n\t * during next cycle.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidSprites: { [index: string]: Array<Sprite> } = {};\r\n\r\n\t/**\r\n\t * Components are added to this list when their data provider changes to\r\n\t * a new one or data is added/removed from their data provider.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidDatas: { [index: string]: Array<Component> } = {};\r\n\r\n\t/**\r\n\t * Components are added to this list when values of their raw data change.\r\n\t * Used when we want a smooth animation from one set of values to another.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidRawDatas: Array<Component> = [];\r\n\r\n\t/**\r\n\t * Components are added to this list when values of their data changes\r\n\t * (but not data provider itself).\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidDataItems: Array<Component> = [];\r\n\r\n\t/**\r\n\t * Components are added to this list when their data range (selection) is\r\n\t * changed, e.g. zoomed.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidDataRange: Array<Component> = [];\r\n\r\n\t/**\r\n\t * A list of [[Sprite]] objects that have invalid(ated) positions, that need\r\n\t * to be recalculated.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidPositions: { [index: string]: Array<Sprite> } = {};\r\n\r\n\t/**\r\n\t * A list of [[Container]] objects with invalid(ated) layouts.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidLayouts: { [index: string]: Array<Container> } = {};\r\n\r\n\t/**\r\n\t * An array holding all active (non-disposed) top level elemens.\r\n\t *\r\n\t * When, for example, a new chart is created, its instance will be added to\r\n\t * this array, and will be removed when the chart is disposed.\r\n\t */\r\n\tpublic baseSprites: Array<Sprite> = [];\r\n\r\n\tpublic baseSpritesByUid: { [index: string]: Sprite } = {};\r\n\r\n\tpublic queue: Array<Sprite> = [];\r\n\r\n\tconstructor() {\r\n\t\tthis.uid = this.getUniqueId();\r\n\r\n\t\tthis.invalidSprites.noBase = [];\r\n\t\tthis.invalidDatas.noBase = [];\r\n\t\tthis.invalidLayouts.noBase = [];\r\n\t\tthis.invalidPositions.noBase = [];\r\n\t}\r\n\r\n\t/**\r\n\t * Generates a unique chart system-wide ID.\r\n\t *\r\n\t * @return Generated ID\r\n\t */\r\n\tpublic getUniqueId(): string {\r\n\t\tlet uid = this._uidCount;\r\n\t\tthis._uidCount += 1;\r\n\t\treturn \"id-\" + uid;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a universal collection for mapping ids with objects.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Map collection\r\n\t */\r\n\tpublic get map(): Dictionary<string, any> {\r\n\t\tif (!this._map) {\r\n\t\t\tthis._map = new Dictionary<string, any>();\r\n\t\t}\r\n\t\treturn this._map;\r\n\t}\r\n\r\n\t/**\r\n\t * Caches value in object's cache.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param key    Key\r\n\t * @param value  Value\r\n\t * @param ttl    TTL in seconds\r\n\t */\r\n\tpublic setCache(key: string, value: any, ttl?: number): void {\r\n\t\tcache.set(this.uid, key, value, ttl);\r\n\t}\r\n\r\n\t/**\r\n\t * Retrieves cached value.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param key    Key\r\n\t * @param value  Value to return if cache is not available\r\n\t * @return Value\r\n\t */\r\n\tpublic getCache(key: string, value: any = undefined): any {\r\n\t\treturn cache.get(this.uid, key, value);\r\n\t}\r\n\r\n\t/**\r\n\t * Dispatches an event using own event dispatcher. Will automatically\r\n\t * populate event data object with event type and target (this element).\r\n\t * It also checks if there are any handlers registered for this sepecific\r\n\t * event.\r\n\t *\r\n\t * @param eventType Event type (name)\r\n\t * @param data      Data to pass into event handler(s)\r\n\t */\r\n\tpublic dispatch<Key extends keyof IRegistryEvents>(eventType: Key, data?: any): void {\r\n\t\t// @todo Implement proper type check\r\n\t\tif (this.events.isEnabled(eventType)) {\r\n\t\t\tif (data) {\r\n\t\t\t\tdata.type = eventType;\r\n\t\t\t\tdata.target = data.target || this;\r\n\t\t\t\t(<any>this.events).dispatch(eventType, {\r\n\t\t\t\t\ttype: eventType,\r\n\t\t\t\t\ttarget: this\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t(<any>this.events).dispatch(eventType, {\r\n\t\t\t\t\ttype: eventType,\r\n\t\t\t\t\ttarget: this\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Works like `dispatch`, except event is triggered immediately, without\r\n\t * waiting for the next frame cycle.\r\n\t *\r\n\t * @param eventType Event type (name)\r\n\t * @param data      Data to pass into event handler(s)\r\n\t */\r\n\tpublic dispatchImmediately<Key extends keyof IRegistryEvents>(eventType: Key, data?: any): void {\r\n\t\t// @todo Implement proper type check\r\n\t\tif (this.events.isEnabled(eventType)) {\r\n\t\t\tif (data) {\r\n\t\t\t\tdata.type = eventType;\r\n\t\t\t\tdata.target = data.target || this;\r\n\t\t\t\t(<any>this.events).dispatchImmediately(eventType, data);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t(<any>this.events).dispatchImmediately(eventType, {\r\n\t\t\t\t\ttype: eventType,\r\n\t\t\t\t\ttarget: this\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a unique placeholder suitable for the key.\r\n\t *\r\n\t * @param key  Key\r\n\t * @return Random string to be used as placeholder\r\n\t */\r\n\tpublic getPlaceholder(key: string): string {\r\n\t\tif ($type.hasValue(this._placeholders[key])) {\r\n\t\t\treturn this._placeholders[key];\r\n\t\t}\r\n\t\tthis._placeholders[key] = \"__amcharts_\" + key + \"_\" + $string.random(8) + \"__\";\r\n\t\treturn this._placeholders[key];\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic addToInvalidComponents(component: Component) {\r\n\t\tif (component.baseId) {\r\n\t\t\t$array.move(this.invalidDatas[component.baseId], component);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$array.move(this.invalidDatas[\"noBase\"], component);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic removeFromInvalidComponents(component: Component) {\r\n\t\tif (component.baseId) {\r\n\t\t\t$array.remove(this.invalidDatas[component.baseId], component);\r\n\t\t}\r\n\r\n\t\t$array.remove(this.invalidDatas[\"noBase\"], component);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic addToInvalidSprites(sprite: Sprite) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.add(this.invalidSprites[sprite.baseId], sprite);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$array.add(this.invalidSprites[\"noBase\"], sprite);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic removeFromInvalidSprites(sprite: Sprite) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.remove(this.invalidSprites[sprite.baseId], sprite);\r\n\t\t}\r\n\r\n\t\t$array.remove(this.invalidSprites[\"noBase\"], sprite);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic addToInvalidPositions(sprite: Sprite) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.add(this.invalidPositions[sprite.baseId], sprite);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$array.add(this.invalidPositions[\"noBase\"], sprite);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic removeFromInvalidPositions(sprite: Sprite) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.remove(this.invalidPositions[sprite.baseId], sprite);\r\n\t\t}\r\n\r\n\t\t$array.remove(this.invalidPositions[\"noBase\"], sprite);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic addToInvalidLayouts(sprite: Container) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.add(this.invalidLayouts[sprite.baseId], sprite);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$array.add(this.invalidLayouts[\"noBase\"], sprite);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic removeFromInvalidLayouts(sprite: Container) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.remove(this.invalidLayouts[sprite.baseId], sprite);\r\n\t\t}\r\n\r\n\t\t$array.remove(this.invalidLayouts[\"noBase\"], sprite);\r\n\t}\r\n}\r\n\r\n/**\r\n * A singleton global instance of [[Registry]].\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport let registry = new Registry();\r\n\r\n\r\n/**\r\n * Returns `true` if object is an instance of the class. It's the same as `instanceof` except it doesn't need to import the class.\r\n *\r\n * @param object Object\r\n * @param name Class name\r\n * @return Is instance of class\r\n */\r\nexport function is<A>(object: any, name: string): object is A {\r\n\tconst x = registry.registeredClasses[name];\r\n\treturn x != null && object instanceof x;\r\n}\r\n","/**\r\n * A collection of utility functions for various type checks and conversion\r\n * @todo Review unused functions for removal\r\n * @hidden\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { percent, Percent, isPercent } from \"./Percent\";\r\n\r\n\r\n/**\r\n * @todo Description\r\n * @ignore Exclude from docs\r\n */\r\nexport type Public<T> = {[P in keyof T]: T[P]};\r\n\r\n\r\n/**\r\n * `Keyof<T>` is the same as `keyof T` except it only accepts string keys, not numbers or symbols.\r\n */\r\nexport type Keyof<T> = Extract<keyof T, string>;\r\n\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * TYPE CHECK\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Returns `true` if value is not a number (NaN).\r\n *\r\n * @param value Input value\r\n * @return Is NaN?\r\n * @deprecated Is not used anywhere. JS built-in isNaN is used everywhere. Maybe we don't need this, or if we do, then we should use it everywhere\r\n */\r\nexport function isNaN(value: number): boolean {\r\n\treturn Number(value) !== value;\r\n}\r\n\r\n/**\r\n * Represents a type for all available JavaScript variable types.\r\n */\r\nexport type Type\r\n\t= \"[object Object]\"\r\n\t| \"[object Array]\"\r\n\t| \"[object String]\"\r\n\t| \"[object Number]\"\r\n\t| \"[object Boolean]\"\r\n\t| \"[object Date]\";\r\n\r\n/**\r\n * Returns a type of the value.\r\n *\r\n * @param value  Input value\r\n * @return Type of the value\r\n */\r\nexport function getType<A>(value: A): Type {\r\n\treturn ({}).toString.call(value) as Type;\r\n}\r\n\r\n/**\r\n * Returns a default value if the passed in value is empty.\r\n *\r\n * @param value     Input value\r\n * @param optional  Default value\r\n * @return Value or default value whichever is available\r\n * @deprecated Not used anywhere\r\n */\r\nexport function getDefault<A>(value: null | undefined | A, optional: A): A {\r\n\treturn value || optional;\r\n}\r\n\r\n/**\r\n * Checks if the passed in value is a string.\r\n *\r\n * @param value  Value\r\n * @return Is string?\r\n * @throws {Error}\r\n * @deprecated Not used anywhere\r\n */\r\nexport function checkString(value: any): value is string {\r\n\tif (typeof value === \"string\") {\r\n\t\treturn true;\r\n\t} else {\r\n\t\tthrow new Error(\"Expected a string but got \" + getType(value));\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks if the passed in value is a boolean.\r\n *\r\n * @param value  Value\r\n * @return Is boolean?\r\n * @throws {Error}\r\n * @deprecated Not used anywhere\r\n */\r\nexport function checkBoolean(value: any): value is boolean {\r\n\tif (typeof value === \"boolean\") {\r\n\t\treturn true;\r\n\t} else {\r\n\t\tthrow new Error(\"Expected a boolean but got \" + getType(value));\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks if the passed in value is a number.\r\n *\r\n * @param value  Value\r\n * @return Is number?\r\n * @throws {Error}\r\n */\r\nexport function checkNumber(value: any): value is number {\r\n\tif (typeof value === \"number\") {\r\n\t\tif (isNaN(value)) {\r\n\t\t\tthrow new Error(\"Expected a number but got NaN\");\r\n\t\t}\r\n\t} else {\r\n\t\tthrow new Error(\"Expected a number but got \" + getType(value));\r\n\t}\r\n\treturn true;\r\n}\r\n\r\n/**\r\n * Checks if the passed in value is an object.\r\n *\r\n * @param value  Value\r\n * @return Is object?\r\n * @throws {Error}\r\n * @todo Is the input type correct?\r\n * @deprecated Not used anywhere\r\n */\r\nexport function checkObject(value: {}): value is {} {\r\n\tconst t = getType(value);\r\n\r\n\tif (t === \"[object Object]\") {\r\n\t\treturn true;\r\n\r\n\t} else {\r\n\t\tthrow new Error(\"Expected an object but got \" + t);\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks if the passed in value is an array.\r\n *\r\n * @param value  Value\r\n * @return Is array?\r\n * @throws {Error}\r\n * @deprecated Not used anywhere\r\n */\r\nexport function checkArray<A>(value: Array<A>): value is Array<A> {\r\n\tif (Array.isArray(value)) {\r\n\t\treturn true;\r\n\r\n\t} else {\r\n\t\tthrow new Error(\"Expected an array but got \" + getType(value));\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks if the passed in value is a Date object.\r\n *\r\n * @param value  Value\r\n * @return Is Date object?\r\n * @throws {Error}\r\n * @deprecated Not used anywhere\r\n */\r\nexport function checkDate(value: Date): value is Date {\r\n\tconst t = getType(value);\r\n\r\n\tif (t === \"[object Date]\") {\r\n\t\treturn true;\r\n\r\n\t} else {\r\n\t\tthrow new Error(\"Expected a date but got \" + t);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * TYPE CASTING\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Casts string or a number into string.\r\n *\r\n * @param value  Input\r\n * @return String value\r\n * @deprecated Not used anywhere\r\n */\r\nexport function castString(value: string | number): string {\r\n\tif (typeof value === \"string\") {\r\n\t\treturn value;\r\n\r\n\t} else if (typeof value === \"number\") {\r\n\t\treturn \"\" + value;\r\n\r\n\t} else {\r\n\t\tthrow new Error(\"Expected a string or number but got \" + getType(value));\r\n\t}\r\n}\r\n\r\n/**\r\n * Casts string or a number into a number.\r\n *\r\n * @param value   Input value\r\n * @return Number  value\r\n * @throws {Error}\r\n */\r\nexport function castNumber(value: string | number | Date): number {\r\n\tif (typeof value === \"string\") {\r\n\t\tconst number = +value;\r\n\r\n\t\tif (isNaN(number)) {\r\n\t\t\tthrow new Error(\"Cannot cast string \" + JSON.stringify(value) + \" to a number\");\r\n\r\n\t\t} else {\r\n\t\t\treturn number;\r\n\t\t}\r\n\r\n\t} else if (typeof value === \"number\") {\r\n\t\tif (isNaN(value)) {\r\n\t\t\tthrow new Error(\"Expected a number but got NaN\");\r\n\r\n\t\t} else {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t} else {\r\n\t\tconst t = getType(value);\r\n\r\n\t\tif (t === \"[object Date]\") {\r\n\t\t\treturn value.getTime();\r\n\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Expected a string, number, or date but got \" + t);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Casts number, string or Date into a Date object.\r\n *\r\n * @param value  Input value\r\n * @return Date object\r\n * @deprecated Not used anywhere\r\n * @throws {Error}\r\n * @hidden\r\n * @deprecated\r\n */\r\n/*export function castDate(value: string | number | Date, formatter?: DateFormatter): Date {\r\n\tif (typeof value === \"string\") {\r\n\t\tif (formatter) {\r\n\t\t\treturn formatter.parse(value);\r\n\t\t}\r\n\t\treturn new Date(value);\r\n\r\n\t} else if (typeof value === \"number\") {\r\n\t\treturn new Date(value);\r\n\r\n\t} else {\r\n\t\tconst t = getType(value);\r\n\r\n\t\tif (t === \"[object Date]\") {\r\n\t\t\treturn value;\r\n\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Expected a string, number, or date but got \" + t);\r\n\t\t}\r\n\t}\r\n}*/\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * QUICK CONVERSION\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n\r\n/**\r\n * Converts any value into `boolean`.\r\n *\r\n * @param value  Source value\r\n * @return `true` or `false`\r\n */\r\nexport function toBoolean(value: any): boolean {\r\n\treturn value ? true : false;\r\n}\r\n\r\n/**\r\n * Converts any value into a `number`.\r\n *\r\n * @param value  Source value\r\n * @return Number representation of value\r\n */\r\nexport function toNumber(value: any): number {\r\n\tif (hasValue(value) && !isNumber(value)) {\r\n\t\tlet converted = Number(value);\r\n\t\tif (isNaN(converted) && isString(value) && value != \"\") {\r\n\t\t\treturn toNumber(value.replace(/[^0-9.\\-]+/g, ''));\r\n\t\t}\r\n\t\treturn converted;\r\n\t}\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Converts any value into a string (text).\r\n *\r\n * @param value  Source value\r\n * @return String representation of the input\r\n */\r\nexport function toText(value: any): string {\r\n\tif (hasValue(value) && !isString(value)) {\r\n\t\tif (isNumber(value)) {\r\n\t\t\treturn castString(value);\r\n\t\t}\r\n\t\telse if (isObject(value)) {\r\n\t\t\treturn value.toString();\r\n\t\t}\r\n\t}\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Converts any value to a number or [[Percent]].\r\n *\r\n * If the parameter is a string and contains \"%\", it will\r\n * convert it into a [[Percent]].\r\n *\r\n * Otherwise, it will convert into a number.\r\n *\r\n * @param value  Number or percent\r\n * @return Percent object\r\n */\r\nexport function toNumberOrPercent(value: any): number | Percent {\r\n\tif (!hasValue(value) || isNumber(value) || isPercent(value)) {\r\n\t\treturn value;\r\n\t}\r\n\tif (isString(value) && value.indexOf(\"%\") != -1) {\r\n\t\treturn percent(toNumber(value));\r\n\t}\r\n\treturn toNumber(value);\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * VALUE PRESENCE CHECK\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines an optional value that can be of any type or `undefined`.\r\n */\r\nexport type Optional<A> = A | undefined;\r\n\r\n/**\r\n * Checks if a variable has a value.\r\n *\r\n * @param a  Input value\r\n * @returns                        Has value?\r\n */\r\nexport function hasValue<A>(a: Optional<A> | null): a is A {\r\n\treturn a != null;\r\n}\r\n\r\n/**\r\n * Returns a value or throws an {Error} exception if the variable has not\r\n * value.\r\n *\r\n * @param a  Input value\r\n * @returns                        Value\r\n */\r\nexport function getValue<A>(a: Optional<A> | null): A {\r\n\tif (hasValue(a)) {\r\n\t\treturn a;\r\n\r\n\t} else {\r\n\t\tthrow new Error(\"Value doesn't exist\");\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns a value, or returns the default value if it doesn't have a value.\r\n *\r\n * @param a  Input value\r\n * @returns                        Value\r\n */\r\nexport function getValueDefault<A>(a: Optional<A> | null, defaultValue: A): A {\r\n\tif (hasValue(a)) {\r\n\t\treturn a;\r\n\r\n\t} else {\r\n\t\treturn defaultValue;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * TYPE CHECK\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Checks if parameter is `Date`.\r\n *\r\n * @param value  Input value\r\n * @return Is Date?\r\n */\r\nexport function isDate(value: any): value is Date {\r\n\treturn getType(value) === \"[object Date]\";\r\n}\r\n\r\n/**\r\n * Checks if parameter is `string`.\r\n *\r\n * @param value  Input value\r\n * @return Is string?\r\n */\r\nexport function isString(value: any): value is string {\r\n\treturn typeof value === \"string\";\r\n}\r\n\r\n/**\r\n * Checks if parameter is `number`.\r\n *\r\n * @param value  Input value\r\n * @return Is number?\r\n */\r\nexport function isNumber(value: any): value is number {\r\n\treturn typeof value === \"number\" && Number(value) == value;\r\n}\r\n\r\n/**\r\n * Checks if parameter is `object`.\r\n *\r\n * @param value  Input value\r\n * @return Is object?\r\n */\r\nexport function isObject(value: any): value is object {\r\n\treturn typeof value === \"object\" && value != null;\r\n}\r\n\r\n/**\r\n * Checks if parameter is `Array`.\r\n *\r\n * @param value  Input value\r\n * @return Is Array?\r\n */\r\nexport function isArray(value: any): value is Array<any> {\r\n\treturn Array.isArray(value);\r\n}\r\n","/**\r\n * A collection of Math-related functions\r\n *\r\n * @todo Comment trigonometric functions?\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { IPoint } from \"../defs/IPoint\";\r\nimport { IRectangle } from \"../defs/IRectangle\";\r\nimport { IRange } from \"../defs/IRange\";\r\nimport * as $type from \"./Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * CONSTANTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nexport const PI = Math.PI;\r\nexport const HALFPI = PI / 2;\r\nexport const RADIANS = PI / 180;\r\nexport const DEGREES = 180 / PI;\r\n\r\n/**\r\n * Converts any value and fits it into a specific value range.\r\n *\r\n * @param value  Source value\r\n * @param min    Minimum allowable value\r\n * @param max    Maximum allowable value\r\n * @return Number\r\n */\r\nexport function toNumberRange(value: any, min: number, max: number): number {\r\n\tif ($type.hasValue(value)) {\r\n\t\tvalue = $type.toNumber(value);\r\n\t\treturn fitToRange(value, min, max);\r\n\t}\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Rounds the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\r\n * @return Rounded value\r\n */\r\nexport function round(value: number, precision?: number, floor?: boolean): number {\r\n\tif (!$type.isNumber(precision) || precision <= 0) {\r\n\r\n\t\tlet rounded = Math.round(value);\r\n\t\tif (floor) {\r\n\t\t\tif (rounded - value == 0.5) {\r\n\t\t\t\trounded--;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn rounded;\r\n\t}\r\n\telse {\r\n\t\tlet d: number = Math.pow(10, precision);\r\n\t\treturn Math.round(value * d) / d;\r\n\t}\r\n}\r\n\r\n/**\r\n * Ceils the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @return Rounded value\r\n */\r\nexport function ceil(value: number, precision?: number): number {\r\n\tif (!$type.isNumber(precision) || precision <= 0) {\r\n\t\treturn Math.ceil(value);\r\n\t}\r\n\telse {\r\n\t\tlet d: number = Math.pow(10, precision);\r\n\t\treturn Math.ceil(value * d) / d;\r\n\t}\r\n}\r\n\r\n/**\r\n * Stretches `t` so that it will always be between `from` and `to`.\r\n *\r\n * @param t     Number from 0 to 1\r\n * @param from  Lowest possible value\r\n * @param to    Highest possible value\r\n * @return Adjusted value\r\n */\r\nexport function stretch(t: number, from: number, to: number): number {\r\n\treturn (t * (to - from)) + from;\r\n}\r\n\r\n\r\n/**\r\n * Adjust numeric value so it fits to specific value range.\r\n *\r\n * @param value     Value\r\n * @param minValue  Lowest possible value\r\n * @param maxValue  Highest possible value\r\n * @return Adjusted value\r\n */\r\nexport function fitToRange(value: number, minValue: $type.Optional<number>, maxValue: $type.Optional<number>): number {\r\n\tif ($type.isNumber(minValue)) {\r\n\t\tif ($type.isNumber(maxValue) && maxValue < minValue) {\r\n\t\t\tlet temp = maxValue;\r\n\t\t\tmaxValue = minValue;\r\n\t\t\tminValue = temp;\r\n\t\t}\r\n\r\n\t\tif (value < minValue) {\r\n\t\t\tvalue = minValue;\r\n\t\t}\r\n\t}\r\n\r\n\tif ($type.isNumber(maxValue)) {\r\n\t\tif (value > maxValue) {\r\n\t\t\tvalue = maxValue;\r\n\t\t}\r\n\t}\r\n\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Returns sine of a number.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\r\nexport function sin(value: number): number {\r\n\treturn round(Math.sin(RADIANS * value), 10);\r\n}\r\n\r\n/**\r\n * Returns tan of a number.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\r\nexport function tan(value: number): number {\r\n\treturn round(Math.tan(RADIANS * value), 10);\r\n}\r\n\r\n/**\r\n * Returns cosine of a number.\r\n *\r\n * @param value  Value\r\n * @return Cosine\r\n */\r\nexport function cos(value: number): number {\r\n\treturn round(Math.cos(RADIANS * value), 10);\r\n}\r\n\r\n/**\r\n * Returns biggest value out of passed in numeric values.\r\n *\r\n * @param left   Numeric value\r\n * @param right  Numeric value\r\n * @return Biggest value\r\n */\r\nexport function max(left: number, right: number): number;\r\nexport function max(left: number, right: $type.Optional<number>): number;\r\nexport function max(left: $type.Optional<number>, right: number): number;\r\nexport function max(left: $type.Optional<number>, right: $type.Optional<number>): $type.Optional<number>;\r\nexport function max(left: any, right: any): any {\r\n\tif ($type.isNumber(left)) {\r\n\t\tif ($type.isNumber(right)) {\r\n\t\t\tif (right > left) {\r\n\t\t\t\treturn right;\r\n\r\n\t\t\t} else {\r\n\t\t\t\treturn left;\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\treturn left;\r\n\t\t}\r\n\r\n\t} else if ($type.isNumber(right)) {\r\n\t\treturn right;\r\n\r\n\t} else {\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns smallest value out of passed in numeric values.\r\n *\r\n * @param left   Numeric value\r\n * @param right  Numeric value\r\n * @return Smallest value\r\n */\r\nexport function min(left: number, right: number): number;\r\nexport function min(left: number, right: $type.Optional<number>): number;\r\nexport function min(left: $type.Optional<number>, right: number): number;\r\nexport function min(left: $type.Optional<number>, right: $type.Optional<number>): $type.Optional<number>;\r\nexport function min(left: any, right: any): any {\r\n\tif ($type.isNumber(left)) {\r\n\t\tif ($type.isNumber(right)) {\r\n\t\t\tif (right < left) {\r\n\t\t\t\treturn right;\r\n\r\n\t\t\t} else {\r\n\t\t\t\treturn left;\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\treturn left;\r\n\t\t}\r\n\r\n\t} else if ($type.isNumber(right)) {\r\n\t\treturn right;\r\n\r\n\t} else {\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns the closest value from the array of values to the reference value.\r\n *\r\n * @param values  Array of values\r\n * @param value   Reference value\r\n * @return Closes value from the array\r\n */\r\nexport function closest(values: number[], referenceValue: number): number {\r\n\treturn values.reduce(function(prev, curr) {\r\n\t\treturn (Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev);\r\n\t});\r\n}\r\n\r\n/**\r\n * Checks whether two ranges of values intersect.\r\n *\r\n * @param range1  Range 1\r\n * @param range2  Range 2\r\n * @return Any intersecting numbers?\r\n */\r\nexport function intersect(range1: IRange, range2: IRange): boolean {\r\n\tlet start1: number = $type.getValue(range1.start);\r\n\tlet start2: number = $type.getValue(range2.start);\r\n\tlet end1: number = $type.getValue(range1.end);\r\n\tlet end2: number = $type.getValue(range2.end);\r\n\r\n\treturn Math.max(start1, start2) <= Math.min(end1, end2);\r\n}\r\n\r\n/**\r\n * Inverts the range of values.\r\n *\r\n * @param range  Range\r\n */\r\nexport function invertRange(range: IRange) {\r\n\tlet start: number = $type.getValue(range.start);\r\n\tlet end: number = $type.getValue(range.end);\r\n\treturn { start: 1 - end, end: 1 - start };\r\n}\r\n\r\n/**\r\n * Returns an intersection range between two ranges of values.\r\n *\r\n * @param range1  Range 1\r\n * @param range2  Range 2\r\n * @return Intersecting value range\r\n */\r\nexport function intersection(range1: IRange, range2: IRange): $type.Optional<IRange> {\r\n\tlet start1: number = $type.getValue(range1.start);\r\n\tlet start2: number = $type.getValue(range2.start);\r\n\tlet end1: number = $type.getValue(range1.end);\r\n\tlet end2: number = $type.getValue(range2.end);\r\n\tlet startMax: number = Math.max(start1, start2);\r\n\tlet endMin: number = Math.min(end1, end2);\r\n\r\n\tif (endMin < startMax) {\r\n\t\treturn undefined;\r\n\t}\r\n\telse {\r\n\t\treturn { start: startMax, end: endMin };\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns pixel \"distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\r\nexport function getDistance(point1: IPoint, point2?: IPoint): number {\r\n\tif (!point1) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (!point2) {\r\n\t\tpoint2 = { x: 0, y: 0 };\r\n\t}\r\n\treturn Math.sqrt(Math.pow(Math.abs(point1.x - point2.x), 2) + Math.pow(Math.abs(point1.y - point2.y), 2));\r\n}\r\n\r\n/**\r\n * Returns pixel \"horizontal distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\r\nexport function getHorizontalDistance(point1: IPoint, point2?: IPoint): number {\r\n\tif (!point1) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (!point2) {\r\n\t\tpoint2 = { x: 0, y: 0 };\r\n\t}\r\n\treturn Math.abs(point1.x - point2.x);\r\n}\r\n\r\n/**\r\n * Returns pixel \"vertical distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\r\nexport function getVerticalDistance(point1: IPoint, point2?: IPoint): number {\r\n\tif (!point1) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (!point2) {\r\n\t\tpoint2 = { x: 0, y: 0 };\r\n\t}\r\n\treturn Math.abs(point1.y - point2.y);\r\n}\r\n\r\n/**\r\n * Returns approximate pixel \"distance\" between two points of cubic curve\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @param controlPointA  Control Point 1\r\n * @param controlPointB  Control Point 2\r\n * @param stepCount  number of steps (the more, the more accurate result)\r\n * @return Distance in relative pixels\r\n */\r\nexport function getCubicCurveDistance(point1: IPoint, point2: IPoint, controlPointA: IPoint, controlPointB: IPoint, stepCount:number): number {\r\n\tif (!point1) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (!point2) {\r\n\t\tpoint2 = { x: 0, y: 0 };\r\n\t}\r\n\r\n\tlet distance = 0;\r\n\tlet prevPoint: IPoint = point1;\r\n\tif (stepCount > 0) {\r\n\t\tfor (let s = 0; s <= stepCount; s++) {\r\n\t\t\tlet point = getPointOnCubicCurve(point1, point2, controlPointA, controlPointB, s / stepCount);\r\n\t\t\tdistance += getDistance(prevPoint, point);\r\n\t\t\tprevPoint = point;\r\n\t\t}\r\n\t}\r\n\treturn distance;\r\n}\r\n\r\n/**\r\n * Returns scale based on original and end position of the two points.\r\n *\r\n * @param point1       Current position of point 1\r\n * @param startPoint1  Start position of point 1\r\n * @param point2       Current position of point 1\r\n * @param startPoint2  Start position of point 2\r\n * @return Scale        Calculated scale\r\n */\r\nexport function getScale(point1: IPoint, startPoint1: IPoint, point2: IPoint, startPoint2: IPoint): number {\r\n\tlet initialDistance: number = getDistance(startPoint1, startPoint2);\r\n\tlet currentDistance: number = getDistance(point1, point2);\r\n\r\n\treturn Math.abs(currentDistance / initialDistance);\r\n}\r\n\r\n/**\r\n * Returns an exact mid point between two points.\r\n *\r\n * @param point1     Position of point 1\r\n * @param point2     Position of point 2\r\n * @return Mid point  Position of mid-point\r\n */\r\nexport function getMidPoint(point1: IPoint, point2: IPoint, position?: number): IPoint {\r\n\tif (!$type.isNumber(position)) {\r\n\t\tposition = 0.5;\r\n\t}\r\n\r\n\treturn {\r\n\t\t\"x\": (point1.x + (point2.x - point1.x) * position),\r\n\t\t\"y\": (point1.y + (point2.y - point1.y) * position)\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns difference in angles between starting and ending position of two\r\n * vectors.\r\n *\r\n * @param point1       Current position of point 1\r\n * @param startPoint1  Start position of point 1\r\n * @param point2       Current position of point 1\r\n * @param startPoint2  Start position of point 2\r\n * @return Angle difference in degrees\r\n */\r\nexport function getRotation(point1: IPoint, startPoint1: IPoint, point2: IPoint, startPoint2: IPoint): number {\r\n\r\n\t// Get start and end angles\r\n\tlet startAngle: number = getAngle(startPoint1, startPoint2);\r\n\tlet angle: number = getAngle(point1, point2);\r\n\r\n\t// Calculate angle\r\n\tlet diff: number = startAngle - angle;\r\n\tif (diff < 0) {\r\n\t\tdiff += 360;\r\n\t}\r\n\r\n\treturn diff;\r\n}\r\n\r\n/**\r\n * Calculates angle of the vector based on two or one point.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Angle in degrees\r\n */\r\nexport function getAngle(point1: IPoint, point2?: IPoint): number {\r\n\tif (!point2) {\r\n\t\tpoint2 = { x: point1.x * 2, y: point1.y * 2 };\r\n\t}\r\n\tlet diffX: number = point2.x - point1.x;\r\n\tlet diffY: number = point2.y - point1.y;\r\n\tlet angle: number = Math.atan2(diffY, diffX) * DEGREES;\r\n\tif (angle < 0) {\r\n\t\tangle += 360;\r\n\t}\r\n\treturn normalizeAngle(angle);\r\n}\r\n\r\n/**\r\n * Returns the shift in coordinates of the center when item is rotated, moved\r\n * and scaled at the same time.\r\n *\r\n * @param center       Current center\r\n * @param point1       Frst reference point\r\n * @param startPoint1  Original position of the first reference point\r\n * @param point2       Second reference point\r\n * @param startPoint2  Original position of the first reference point\r\n * @return Shift in center point coordinates\r\n */\r\nexport function getCenterShift(center: IPoint, point1: IPoint, startPoint1: IPoint, point2: IPoint, startPoint2: IPoint): IPoint {\r\n\r\n\t// Get angle\r\n\tlet angle: number = getRotation(point1, startPoint1, point2, startPoint2) - 90;\r\n\tif (angle < 0) {\r\n\t\tangle += 360;\r\n\t}\r\n\r\n\t// Get distance between new position\r\n\tlet distance: number = getDistance(point1, point2);\r\n\r\n\t// Calculate new X\r\n\tlet x: number = Math.cos(angle) / distance + point1.x;\r\n\tlet y: number = Math.cos(angle) / distance + point1.y;\r\n\r\n\tlet shift: IPoint = {\r\n\t\t\"x\": x - center.x,\r\n\t\t\"y\": y - center.y\r\n\t}\r\n\treturn shift;\r\n}\r\n\r\n/**\r\n * Converts an array of points into a bounding box rectangle.\r\n *\r\n * Array can contain any number of points.\r\n *\r\n * @param points  Points\r\n * @return Bounding box rectangle\r\n */\r\nexport function getBBox(points: IPoint[]): $type.Optional<IRectangle> {\r\n\tif (points) {\r\n\t\tlet length = points.length;\r\n\r\n\t\tif (length !== 0) {\r\n\t\t\tlet left!: number;\r\n\t\t\tlet right!: number;\r\n\t\t\tlet top!: number;\r\n\t\t\tlet bottom!: number;\r\n\r\n\t\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\t\tlet point: IPoint = points[i];\r\n\r\n\t\t\t\tif (!$type.isNumber(right) || (point.x > right)) {\r\n\t\t\t\t\tright = point.x;\r\n\t\t\t\t}\r\n\t\t\t\tif (!$type.isNumber(left) || (point.x < left)) {\r\n\t\t\t\t\tleft = point.x;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!$type.isNumber(top) || (point.y < top)) {\r\n\t\t\t\t\ttop = point.y;\r\n\t\t\t\t}\r\n\t\t\t\tif (!$type.isNumber(bottom) || (point.y > bottom)) {\r\n\t\t\t\t\tbottom = point.y;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn { x: left, y: top, width: right - left, height: bottom - top };\r\n\t\t}\r\n\t}\r\n\r\n\treturn { x: 0, y: 0, width: 0, height: 0 };\r\n}\r\n\r\n/**\r\n * Returns a [[IRectangle]] object representing a common rectangle that fits\r\n * all passed in rectangles in it.\r\n *\r\n * @param rectangles  An array of rectangles\r\n * @return Common rectangle\r\n */\r\nexport function getCommonRectangle(rectangles: IRectangle[]): $type.Optional<IRectangle> {\r\n\tlet length = rectangles.length;\r\n\r\n\tif (length !== 0) {\r\n\t\tlet minX!: number;\r\n\t\tlet minY!: number;\r\n\t\tlet maxX!: number;\r\n\t\tlet maxY!: number;\r\n\r\n\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\tlet rectangle = rectangles[i];\r\n\t\t\tminX = min(rectangle.x, minX);\r\n\t\t\tminY = min(rectangle.y, minY);\r\n\t\t\tmaxX = max(rectangle.x + rectangle.width, maxX);\r\n\t\t\tmaxY = max(rectangle.y + rectangle.height, maxY);\r\n\t\t}\r\n\r\n\t\treturn { x: minX, y: minY, width: maxX - minX, height: maxY - minY };\r\n\t}\r\n}\r\n\r\n/**\r\n * [getPointOnQuadraticCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA        [description]\r\n * @param pointB        [description]\r\n * @param controlPoint  [description]\r\n * @param position      [description]\r\n * @return [description]\r\n */\r\nexport function getPointOnQuadraticCurve(pointA: IPoint, pointB: IPoint, controlPoint: IPoint, position: number): IPoint {\r\n\tlet x: number = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\r\n\tlet y: number = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\r\n\treturn { x: x, y: y };\r\n}\r\n\r\n/**\r\n * [getPointOnCubicCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA         [description]\r\n * @param pointB         [description]\r\n * @param controlPointA  [description]\r\n * @param controlPointB  [description]\r\n * @param position       [description]\r\n * @return [description]\r\n */\r\nexport function getPointOnCubicCurve(pointA: IPoint, pointB: IPoint, controlPointA: IPoint, controlPointB: IPoint, position: number): IPoint {\r\n\tlet point: IPoint = { x: 0, y: 0 };\r\n\tlet mt1: number = 1 - position;\r\n\tlet mt2: number = mt1 * mt1;\r\n\tlet mt3: number = mt2 * mt1;\r\n\r\n\tpoint.x = pointA.x * mt3 + controlPointA.x * 3 * mt2 * position + controlPointB.x * 3 * mt1 * position * position + pointB.x * position * position * position;\r\n\tpoint.y = pointA.y * mt3 + controlPointA.y * 3 * mt2 * position + controlPointB.y * 3 * mt1 * position * position + pointB.y * position * position * position;\r\n\r\n\treturn point;\r\n}\r\n\r\n/**\r\n * [getCubicControlPointA description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\r\nexport function getCubicControlPointA(p0: IPoint, p1: IPoint, p2: IPoint, p3: IPoint, tensionX: number, tensionY: number): IPoint {\r\n\ttensionX = adjustTension(tensionX);\r\n\ttensionY = adjustTension(tensionY);\r\n\treturn { x: ((-p0.x + p1.x / tensionX + p2.x) * tensionX), y: ((-p0.y + p1.y / tensionY + p2.y) * tensionY) };\r\n}\r\n\r\n/**\r\n * [getCubicControlPointB description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\r\nexport function getCubicControlPointB(p0: IPoint, p1: IPoint, p2: IPoint, p3: IPoint, tensionX: number, tensionY: number): IPoint {\r\n\ttensionX = adjustTension(tensionX);\r\n\ttensionY = adjustTension(tensionY);\r\n\treturn { x: ((p1.x + p2.x / tensionX - p3.x) * tensionX), y: ((p1.y + p2.y / tensionY - p3.y) * tensionY) };\r\n}\r\n\r\n/**\r\n * [adjustTension description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param tension  [description]\r\n * @return [description]\r\n */\r\nexport function adjustTension(tension: number): number {\r\n\treturn 1 - tension + 0.00001;\r\n}\r\n\r\n/**\r\n * [normalizeAngle description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param value  [description]\r\n * @return [description]\r\n */\r\nexport function normalizeAngle(value: number): number {\r\n\tif (value == 360) {\r\n\t\treturn 360;\r\n\t}\r\n\treturn value % 360;\r\n}\r\n\r\n\r\n\r\n/**\r\n * [normalizeAngleToRange description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @todo review this with various angles, can be tested on radar chart with custom start/end angles\r\n * @param value       [description]\r\n * @param startAngle  [description]\r\n * @param endAngle    [description]\r\n * @return [description]\r\n */\r\nexport function fitAngleToRange(value: number, startAngle: number, endAngle: number): number {\r\n\r\n\tif (startAngle > endAngle) {\r\n\t\tlet temp: number = startAngle;\r\n\t\tstartAngle = endAngle;\r\n\t\tendAngle = temp;\r\n\t}\r\n\r\n\tvalue = normalizeAngle(value);\r\n\r\n\tlet count = (startAngle - normalizeAngle(startAngle)) / 360;\r\n\r\n\tif (value < startAngle) {\r\n\t\tvalue += 360 * (count + 1);\r\n\t}\r\n\r\n\tlet maxEnd: number = startAngle + (endAngle - startAngle) / 2 + 180;\r\n\tlet maxStart: number = startAngle + (endAngle - startAngle) / 2 - 180;\r\n\r\n\tif (value > endAngle) {\r\n\r\n\t\tif (value - 360 > startAngle) {\r\n\t\t\tvalue -= 360;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (value < maxEnd) {\r\n\t\t\t\tvalue = endAngle;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalue = startAngle;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (value < startAngle) {\r\n\t\tif (value > maxStart) {\r\n\t\t\tvalue = startAngle;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tvalue = endAngle;\r\n\t\t}\r\n\t}\r\n\r\n\treturn value;\r\n}\r\n\r\n\r\n/**\r\n * Returns [[IRectangle]] of an arc in relative values, assuming that the\r\n * center is at the circle center.\r\n *\r\n * Used to find out max radius of an arc.\r\n *\r\n * @ignore Exclude from docs\r\n * @param startAngle  Start angle\r\n * @param endAngle    End angle\r\n * @param radius    \t Relative radius\r\n * @return Rectangle\r\n */\r\nexport function getArcRect(startAngle: number, endAngle: number, radius?: number): IRectangle {\r\n\r\n\tlet minX = Number.MAX_VALUE;\r\n\tlet minY = Number.MAX_VALUE;\r\n\tlet maxX = -Number.MAX_VALUE;\r\n\tlet maxY = -Number.MAX_VALUE;\r\n\r\n\tlet bpoints = [];\r\n\r\n\tif (!$type.isNumber(radius)) {\r\n\t\tradius = 1;\r\n\t}\r\n\r\n\tbpoints.push(getArcPoint(radius, startAngle));\r\n\tbpoints.push(getArcPoint(radius, endAngle));\r\n\r\n\tlet fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\r\n\tlet toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\r\n\r\n\tfor (let angle = fromAngle; angle <= toAngle; angle += 90) {\r\n\t\tif (angle >= startAngle && angle <= endAngle) {\r\n\t\t\tbpoints.push(getArcPoint(radius, angle));\r\n\t\t}\r\n\t}\r\n\r\n\tfor (let i = 0; i < bpoints.length; i++) {\r\n\t\tlet pt = bpoints[i];\r\n\t\tif (pt.x < minX) { minX = pt.x; }\r\n\t\tif (pt.y < minY) { minY = pt.y; }\r\n\t\tif (pt.x > maxX) { maxX = pt.x; }\r\n\t\tif (pt.y > maxY) { maxY = pt.y; }\r\n\t}\r\n\r\n\treturn ({ x: minX, y: minY, width: maxX - minX, height: maxY - minY });\r\n}\r\n\r\n/**\r\n * Returns point on arc\r\n *\r\n * @param center point\r\n * @param radius\r\n * @param arc\r\n * @return {boolean}\r\n */\r\nexport function getArcPoint(radius: number, arc: number) {\r\n\treturn ({ x: radius * cos(arc), y: radius * sin(arc) });\r\n}\r\n\r\n/**\r\n * Returns true if a point is within rectangle\r\n *\r\n * @param point\r\n * @param rectangle\r\n * @return {boolean}\r\n */\r\nexport function isInRectangle(point: IPoint, rectangle: IRectangle): boolean {\r\n\tif (point.x >= rectangle.x && point.x <= rectangle.x + rectangle.width && point.y > rectangle.y && point.y < rectangle.y + rectangle.height) {\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n\r\nexport function getLineIntersection(pointA1: IPoint, pointA2: IPoint, pointB1: IPoint, pointB2: IPoint) {\r\n\tlet x = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.x - pointB2.x) - (pointA1.x - pointA2.x) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));\r\n\tlet y = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));\r\n\treturn { x: x, y: y };\r\n}\r\n","/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Ordering } from \"./Order\";\r\nimport { Optional } from \"./Type\";\r\nimport * as $math from \"./Math\";\r\nimport * as $type from \"./Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * UTILITY FUNCTIONS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Searches `array` for `value`.\r\n *\r\n * Returns -1 if not found.\r\n *\r\n * @param array  Source array\r\n * @param value  Value to search\r\n * @returns Index\r\n */\r\nexport function indexOf<A>(array: ArrayLike<A>, value: A): number {\r\n\tconst length = array.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\t// TODO handle NaN\r\n\t\tif (array[i] === value) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\r\n\treturn -1;\r\n}\r\n\r\n/**\r\n * Calls `test` for each element in `array`.\r\n *\r\n * If `test` returns `true` then it immediately returns `true`.\r\n *\r\n * If `test` returns `false` for all of the elements in `array` then it returns `false`.\r\n *\r\n * @param array  Source array\r\n * @param test   Function which is called on each element\r\n * @returns Whether `test` returned true or not\r\n */\r\nexport function any<A>(array: ArrayLike<A>, test: (value: A) => boolean): boolean {\r\n\tconst length = array.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\tif (test(array[i])) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n/**\r\n * Calls `fn` function for every member of array and returns a new array out\r\n * of all outputs.\r\n *\r\n * @param array  Source array\r\n * @param fn     Callback function\r\n * @returns New array\r\n */\r\nexport function map<A, B>(array: ArrayLike<A>, fn: (value: A, index: number) => B): Array<B> {\r\n\tconst length = array.length;\r\n\tconst output = new Array(length);\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\toutput[i] = fn(array[i], i);\r\n\t}\r\n\r\n\treturn output;\r\n}\r\n\r\n/**\r\n * Iterates through all items in array and calls `fn` function for each of\r\n * them.\r\n *\r\n * @param array  Source array\r\n * @param fn     Callback function\r\n */\r\nexport function each<A>(array: ArrayLike<A>, fn: (value: A, index: number) => void): void {\r\n\tconst length = array.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\tfn(array[i], i);\r\n\t}\r\n}\r\n\r\n/**\r\n * Iterates through all items in array in reverse order and calls `fn` function for each of\r\n * them.\r\n *\r\n * @param array  Source array\r\n * @param fn     Callback function\r\n */\r\nexport function eachReverse<A>(array: ArrayLike<A>, fn: (value: A, index: number) => void): void {\r\n\tlet i = array.length;\r\n\r\n\twhile (i--) {\r\n\t\tfn(array[i], i);\r\n\t}\r\n}\r\n\r\n/**\r\n * Iterates through all items in array and calls `fn` function for each of\r\n * them.\r\n *\r\n * If `fn` call evaluates to `false`, further iteration is cancelled.\r\n *\r\n * @param array  Source array\r\n * @param fn     Callback function\r\n */\r\nexport function eachContinue<A>(array: ArrayLike<A>, fn: (value: A, index: number) => boolean): void {\r\n\tconst length = array.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\tif (!fn(array[i], i)) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Shifts an item at `index` towards beginning of the array.\r\n *\r\n * @param array  Source array\r\n * @param index  Target element index\r\n */\r\nexport function shiftLeft<A>(array: Array<A>, index: number): void {\r\n\tconst length = array.length;\r\n\r\n\tfor (let i = index; i < length; ++i) {\r\n\t\tarray[i - index] = array[i];\r\n\t}\r\n\r\n\tarray.length = length - index;\r\n}\r\n\r\n/**\r\n * Returns the last item of the array.\r\n *\r\n * @param array  Source array\r\n * @returns Last item\r\n */\r\nexport function last<A>(array: Array<A>): Optional<A> {\r\n\tconst length = array.length;\r\n\treturn length ? array[length - 1] : undefined;\r\n}\r\n\r\n/**\r\n * Returns the first item of the array.\r\n *\r\n * @param array  Source array\r\n * @returns Last item\r\n */\r\nexport function first<A>(array: Array<A>): Optional<A> {\r\n\treturn array[0];\r\n}\r\n\r\n/**\r\n * Inserts `element` into `array` at `index`.\r\n *\r\n * Caps `index` to be between `0` and `array.length`\r\n *\r\n * @param array    Source array\r\n * @param element  Item to insert\r\n * @param array    Index to insert item at\r\n */\r\nexport function insert<A>(array: Array<A>, element: A, index: number): void {\r\n\t//if (array) {\r\n\tindex = $math.fitToRange(index, 0, array.length);\r\n\tarray.splice(index, 0, element);\r\n\t//}\r\n}\r\n\r\n/**\r\n * Removes all copies of `element` from `array` (if they exist) and then\r\n * inserts `element` at `index`.\r\n *\r\n * @param array    Source array\r\n * @param element  Item\r\n * @param array    Index to move item to\r\n */\r\nexport function setIndex<A>(array: Array<A>, element: A, index: number): void {\r\n\tremove(array, element);\r\n\tinsert(array, element, index);\r\n}\r\n\r\n\r\n/**\r\n * Pushes all of the elements from `input` into `array`.\r\n *\r\n * @param array  Output array\r\n * @param input  Input array\r\n */\r\nexport function pushAll<A>(array: Array<A>, input: Array<A>) {\r\n\tconst length = input.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\tarray.push(input[i]);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Removes `element` from `array`.\r\n *\r\n * If there are multiple copies of `element`, they are all removed.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to remove\r\n */\r\nexport function remove<A>(array: Array<A>, element: A): boolean {\r\n\tlet found: boolean = false;\r\n\tlet index: number = array.indexOf(element);\r\n\r\n\tif (index !== -1) {\r\n\t\tfound = true;\r\n\t\tarray.splice(index, 1);\r\n\r\n\t\tlet length: number = array.length;\r\n\r\n\t\twhile (index < length) {\r\n\t\t\t// TODO handle NaN\r\n\t\t\tif (array[index] === element) {\r\n\t\t\t\tarray.splice(index, 1);\r\n\t\t\t\t--length;\r\n\r\n\t\t\t} else {\r\n\t\t\t\t++index;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn found;\r\n}\r\n\r\n/**\r\n * Adds an `element` to `array`.\r\n *\r\n * If array already contains and item like this, it is removed before adding\r\n * it again.\r\n *\r\n * Optionally `toIndex` can be specified to add element at specific index.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to add\r\n * @param array    Index to move item to\r\n */\r\nexport function move<A>(array: Array<A>, element: A, toIndex?: number): void {\r\n\t// @todo this implementation must be the same as the List.moveValue method\r\n\t// @todo don't do anything if the desired index is the same as the current index\r\n\tlet index = indexOf(array, element);\r\n\r\n\t// @todo remove all old values rather than only the first ?\r\n\tif (index !== -1) {\r\n\t\tremoveIndex(array, index);\r\n\t}\r\n\r\n\tif (toIndex == null) {\r\n\t\tarray.push(element);\r\n\t} else {\r\n\t\tinsertIndex(array, toIndex, element);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Inserts `element` into `array` at `index`.\r\n *\r\n * If `index` is not provided, it will insert `element` at the end of `array`.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to add\r\n * @param array    Index to add item at\r\n */\r\nexport function add<A>(array: Array<A>, element: A, index?: number): void {\r\n\t// Append to the end if index is not set\r\n\tif (!$type.isNumber(index)) {\r\n\t\tarray.push(element);\r\n\t}\r\n\r\n\t// Add to the beginning of array if index is 0\r\n\telse if (index === 0) {\r\n\t\tarray.unshift(element);\r\n\t}\r\n\t// Add to indicated place if index is set\r\n\telse {\r\n\t\tarray.splice(index, 0, element);\r\n\t}\r\n}\r\n\r\n/**\r\n * Removes `element` from `array` (if it exists) and then inserts `element` at\r\n * `index`.\r\n *\r\n * If `index` is not provided, it will insert `element` at the end of `array`.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to remove\r\n * @param array    Index to move item to\r\n */\r\nexport function replace<A>(array: Array<A>, element: A, index?: number): void {\r\n\t// check if exists\r\n\tlet ind: number = array.indexOf(element);\r\n\r\n\t// remove if exists\r\n\tif (ind !== -1) {\r\n\t\tarray.splice(ind, 1);\r\n\t}\r\n\r\n\t// add to end if index is not set\r\n\tif (!$type.isNumber(index)) {\r\n\t\tarray.push(element);\r\n\t}\r\n\t// add to indicated place if index is set\r\n\telse {\r\n\t\tarray.splice(index, 0, element);\r\n\t}\r\n}\r\n\r\n/**\r\n * Wraps `input` in an array, if it isn't already an array.\r\n *\r\n * @param input  Source value\r\n * @return An array\r\n */\r\nexport function toArray<A>(input: Array<A> | A): Array<A> {\r\n\tif (Array.isArray(input)) {\r\n\t\treturn input;\r\n\t}\r\n\telse {\r\n\t\treturn [input];\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns `true` if `element` exists in `array`.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to search for\r\n * @returns Item in array?\r\n */\r\nexport function has<A>(array: ArrayLike<A>, element: A): boolean {\r\n\treturn indexOf(array, element) !== -1;\r\n}\r\n\r\n/**\r\n * Returns a shallow copy of `array`.\r\n *\r\n * @param array  Source array\r\n * @returns Copy of the array\r\n */\r\nexport function copy<A>(array: ArrayLike<A>): Array<A> {\r\n\tconst length = array.length;\r\n\r\n\t// It's faster to create the array with a pre-defined length\r\n\tconst output = new Array(length);\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\t// Because the array has a pre-defined length, we have to assign rather than push\r\n\t\t// This is also faster than pushing\r\n\t\toutput[i] = array[i];\r\n\t}\r\n\r\n\treturn output;\r\n}\r\n\r\n\r\n/**\r\n * Returns a copy of `array` which contains all the elements between `start`\r\n * and `end`. (including `start` and excluding `end`)\r\n *\r\n * If `end` is not provided, it defaults to `array.length`.\r\n *\r\n * @param array  Source array\r\n * @param start  Start index\r\n * @param end    End index\r\n * @returns Part of the array\r\n */\r\nexport function slice<A>(array: ArrayLike<A>, start: number, end: number = array.length): Array<A> {\r\n\tconst output = new Array(end - start);\r\n\r\n\tfor (let i = start; i < end; ++i) {\r\n\t\toutput[i - start] = array[i];\r\n\t}\r\n\r\n\treturn output;\r\n}\r\n\r\n/**\r\n * Inserts a value into array at specific index.\r\n *\r\n * @param array  Source array\r\n * @param index  Index\r\n * @param value  Value to insert\r\n */\r\nexport function insertIndex<A>(array: Array<A>, index: number, value: A): void {\r\n\tarray.splice(index, 0, value);\r\n}\r\n\r\n/**\r\n * Removes a value from array at specific index.\r\n *\r\n * @param array  Source array\r\n * @param index  Index\r\n */\r\nexport function removeIndex<A>(array: Array<A>, index: number): void {\r\n\tarray.splice(index, 1);\r\n}\r\n\r\n/**\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nexport interface SortResult {\r\n\tfound: boolean;\r\n\tindex: number\r\n}\r\n\r\n/**\r\n * Orders an array using specific `ordering` function and returns index of\r\n * the `value`.\r\n *\r\n * @ignore Exclude from docs\r\n * @param array     Source array\r\n * @param ordering  An ordering function\r\n * @param value     Value to search for\r\n * @returns Result of the search\r\n */\r\nexport function getSortedIndex<A>(array: ArrayLike<A>, ordering: (left: A, right: A) => Ordering, value: A): SortResult {\r\n\tlet start = 0;\r\n\tlet end   = array.length;\r\n\tlet found = false;\r\n\r\n\twhile (start < end) {\r\n\t\t// TODO is this faster/slower than using Math.floor ?\r\n\t\tconst pivot = (start + end) >> 1;\r\n\r\n\t\tconst order = ordering(value, array[pivot]);\r\n\r\n\t\t// less\r\n\t\tif (order < 0) {\r\n\t\t\tend = pivot;\r\n\r\n\t\t// equal\r\n\t\t} else if (order === 0) {\r\n\t\t\tfound = true;\r\n\t\t\tstart = pivot + 1;\r\n\r\n\t\t// more\r\n\t\t} else {\r\n\t\t\tstart = pivot + 1;\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tfound: found,\r\n\t\tindex: (found ? start - 1 : start)\r\n\t};\r\n}\r\n\r\n/**\r\n * Searches the array using custom function and returns index of the item if\r\n * found.\r\n *\r\n * Will call `matches` function on all items of the array. If return value\r\n * evaluates to `true`, index is returned.\r\n *\r\n * Otherwise returns -1.\r\n *\r\n * @param array    Source array\r\n * @param matches  Search function\r\n * @returns Index of the item if found\r\n */\r\nexport function findIndex<A>(array: ArrayLike<A>, matches: (value: A, index: number) => boolean): number {\r\n\tconst length = array.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\tif (matches(array[i], i)) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\r\n\treturn -1;\r\n}\r\n\r\n/**\r\n * Searches the array using custom function and returns item if found.\r\n *\r\n * Will call `matches` function on all items of the array. If return value\r\n * evaluates to `true`, index is returned.\r\n *\r\n * Otherwise returns `undefined`.\r\n *\r\n * @param array    Source array\r\n * @param matches  Search function\r\n * @returns Item if found\r\n */\r\nexport function find<A>(array: ArrayLike<A>, matches: (value: A, index: number) => boolean): A | undefined {\r\n\tconst index = findIndex(array, matches);\r\n\r\n\tif (index !== -1) {\r\n\t\treturn array[index];\r\n\t}\r\n}\r\n\r\n/**\r\n * Iterates through all items in array and calls `fn` function for each of\r\n * them.\r\n *\r\n * @param array  Source array\r\n * @param fn     Callback function\r\n */\r\nexport function shuffle<A>(array: Array<A>) {\r\n\t// https://stackoverflow.com/a/2450976/449477\r\n\tlet currentIndex = array.length,\r\n\t\ttemporaryValue,\r\n\t\trandomIndex;\r\n\r\n\t// While there remain elements to shuffle...\r\n\twhile (0 !== currentIndex) {\r\n\t\t// Pick a remaining element...\r\n\t\trandomIndex = Math.floor(Math.random() * currentIndex);\r\n\t\tcurrentIndex -= 1;\r\n\r\n\t\t// And swap it with the current element.\r\n\t\ttemporaryValue = array[currentIndex];\r\n\t\tarray[currentIndex] = array[randomIndex];\r\n\t\tarray[randomIndex] = temporaryValue;\r\n\t}\r\n}\r\n","/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport * as $array from \"./Array\";\r\nimport * as $type from \"./Type\";\r\nimport { Optional } from \"./Type\";\r\n\r\n/**\r\n * Defines interface for disposable objects.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport interface IDisposer {\r\n\tisDisposed(): boolean;\r\n\tdispose(): void;\r\n}\r\n\r\n/**\r\n * A base class for disposable objects.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport class Disposer implements IDisposer {\r\n\r\n\t/**\r\n\t * Is object disposed?\r\n\t */\r\n\tprivate _disposed: boolean;\r\n\r\n\t/**\r\n\t * Method that disposes the object.\r\n\t */\r\n\tprivate _dispose: () => void;\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t *\r\n\t * @param dispose  Function that disposes object\r\n\t */\r\n\tconstructor(dispose: () => void) {\r\n\t\tthis._disposed = false;\r\n\t\tthis._dispose = dispose;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if object is disposed.\r\n\t *\r\n\t * @return Disposed?\r\n\t */\r\n\tpublic isDisposed(): boolean {\r\n\t\treturn this._disposed;\r\n\t}\r\n\r\n\t/**\r\n\t * Disposes the object.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tif (!this._disposed) {\r\n\t\t\tthis._disposed = true;\r\n\t\t\tthis._dispose();\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * A collection of related disposers that can be disposed in one go.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport class MultiDisposer extends Disposer {\r\n\tconstructor(disposers: Array<IDisposer>) {\r\n\t\tsuper(() => {\r\n\t\t\t$array.each(disposers, (x) => {\r\n\t\t\t\tx.dispose();\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n}\r\n\r\n/**\r\n * A special kind of Disposer that has attached value set.\r\n *\r\n * If a new value is set using `set()` method, the old disposer value is\r\n * disposed.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nexport class MutableValueDisposer<T extends IDisposer> extends Disposer {\r\n\r\n\t/**\r\n\t * Current disposer.\r\n\t */\r\n\tprivate _disposer: Optional<IDisposer>;\r\n\r\n\t/**\r\n\t * Current value.\r\n\t */\r\n\tprivate _value: Optional<T>;\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper(() => {\r\n\t\t\tif ($type.hasValue(this._disposer)) {\r\n\t\t\t\tthis._disposer.dispose();\r\n\t\t\t\tthis._disposer = undefined;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returns current value.\r\n\t *\r\n\t * @return Value\r\n\t */\r\n\tpublic get(): Optional<T> {\r\n\t\treturn this._value;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets value and disposes previous disposer if it was set.\r\n\t *\r\n\t * @param value     New value\r\n\t * @param disposer  Disposer\r\n\t */\r\n\tpublic set(value: Optional<T>, disposer: Optional<IDisposer>): void {\r\n\t\tif ($type.hasValue(this._disposer)) {\r\n\t\t\tthis._disposer.dispose();\r\n\t\t}\r\n\r\n\t\tthis._disposer = disposer;\r\n\t\tthis._value = value;\r\n\t}\r\n\r\n\t/**\r\n\t * Resets the disposer value.\r\n\t */\r\n\tpublic reset(): void {\r\n\t\tthis.set(undefined, undefined);\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nexport class CounterDisposer extends Disposer {\r\n\r\n\t/**\r\n\t * [_counter description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprivate _counter: number = 0;\r\n\r\n\t/**\r\n\t * [increment description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tpublic increment() {\r\n\t\t// TODO throw an error if it is disposed\r\n\t\t++this._counter;\r\n\r\n\t\t// TODO make this more efficient\r\n\t\treturn new Disposer(() => {\r\n\t\t\t--this._counter;\r\n\r\n\t\t\tif (this._counter === 0) {\r\n\t\t\t\tthis.dispose();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n}\r\n","/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\nimport { IClone } from \"./Clone\";\nimport { Ordering } from \"./Order\";\nimport * as $array from \"./Array\";\nimport * as $type from \"./Type\";\n\n\n/**\n * ============================================================================\n * UTILITY FUNCTIONS\n * ============================================================================\n * @hidden\n */\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport interface Iterator<A> {\n\t(push: (value: A) => boolean): void;\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport interface Iterable<A> {\n\titerator(): Iterator<A>;\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function fromArray<A>(array: Array<A>): Iterator<A> {\n\treturn (push) => {\n\t\tconst length = array.length;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tif (!push(array[i])) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function length<A>(iter: Iterator<A>): number {\n\tlet sum = 0;\n\n\titer((_) => {\n\t\t++sum;\n\t\treturn true;\n\t});\n\n\treturn sum;\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function toArray<A>(iter: Iterator<A>): Array<A> {\n\tconst output: Array<A> = [];\n\n\titer((value) => {\n\t\toutput.push(value);\n\t\treturn true;\n\t});\n\n\treturn output;\n}\n\n/**\n * [iter description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function eachContinue<A>(iter: Iterator<A>, fn: (value: A) => boolean): void {\n\titer(fn);\n}\n\n/**\n * [iter description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function each<A>(iter: Iterator<A>, fn: (value: A) => void): void {\n\titer((value) => {\n\t\tfn(value);\n\t\treturn true;\n\t});\n}\n\n/**\n * [iter description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function sort<A>(iter: Iterator<A>, fn: (left: A, right: A) => Ordering): Iterator<A> {\n\treturn fromArray(toArray(iter).sort(fn));\n}\n\n/**\n * [A description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function map<A, B>(iter: Iterator<A>, fn: (value: A) => B): Iterator<B> {\n\treturn (push) => iter((value) => push(fn(value)));\n}\n\n/**\n * [iter description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function filter<A>(iter: Iterator<A>, fn: (value: A) => boolean): Iterator<A> {\n\treturn (push) => iter((value) => {\n\t\tif (fn(value)) {\n\t\t\treturn push(value);\n\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t});\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function concat<A>(...args: Array<Iterator<A>>): Iterator<A> {\n\treturn (push) => {\n\t\tlet go = true;\n\n\t\tconst push2 = (value: A) => (go = push(value));\n\n\t\tconst length = args.length;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\targs[i](push2);\n\n\t\t\tif (!go) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function flatten<A>(iter: Iterator<Iterator<A>>): Iterator<A> {\n\treturn (push) => {\n\t\tlet go = true;\n\n\t\tconst push2 = (value: A) => (go = push(value));\n\n\t\titer((value) => {\n\t\t\tvalue(push2);\n\t\t\treturn go;\n\t\t});\n\t};\n}\n\n/**\n * [number description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function indexed<A>(iter: Iterator<A>): Iterator<[number, A]> {\n\treturn (push) => {\n\t\tlet index = 0;\n\n\t\titer((value) => push([index++, value]));\n\t};\n}\n\n/**\n * [iter description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function findIndex<A>(iter: Iterator<A>, matches: (value: A) => boolean): number {\n\tlet found = false;\n\tlet i = 0;\n\n\titer((value) => {\n\t\tif (matches(value)) {\n\t\t\tfound = true;\n\t\t\treturn false;\n\n\t\t} else {\n\t\t\t++i;\n\t\t\treturn true;\n\t\t}\n\t});\n\n\treturn (found ? i : -1);\n}\n\n/**\n * [iter description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function find<A>(iter: Iterator<A>, matches: (value: A) => boolean): A | undefined {\n\tlet output;\n\n\titer((value) => {\n\t\tif (matches(value)) {\n\t\t\toutput = value;\n\t\t\treturn false;\n\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t});\n\n\treturn output;\n}\n\n/**\n * [A description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function findMap<A, B>(iter: Iterator<A>, matches: (value: A) => B | null): B | undefined {\n\tlet output;\n\n\titer((value) => {\n\t\tconst v = matches(value);\n\n\t\tif (v !== null) {\n\t\t\toutput = v;\n\t\t\treturn false;\n\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t});\n\n\treturn output;\n}\n\n/**\n * [iter description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function contains<A>(iter: Iterator<A>, matches: (value: A) => boolean): boolean {\n\tlet output = false;\n\n\titer((value) => {\n\t\tif (matches(value)) {\n\t\t\toutput = true;\n\t\t\treturn false;\n\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t});\n\n\treturn output;\n}\n\n/**\n * [A description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function foldl<A, B>(iter: Iterator<A>, init: B, fn: (state: B, value: A) => B): B {\n\titer((value) => {\n\t\tinit = fn(init, value);\n\t\treturn true;\n\t});\n\n\treturn init;\n}\n\n/**\n * [min2 description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param left [description]\n * @param right [description]\n * @return [description]\n */\nfunction min2(left: number | null, right: number): number {\n\tif (left == null || right < left) {\n\t\treturn right;\n\n\t} else {\n\t\treturn left;\n\t}\n}\n\n/**\n * [min description]\n *\n * @ignore Exclude from docs\n * @todo Verify that this works correctly\n * @todo Description\n * @param a [description]\n * @return [description]\n */\nexport function min(a: Iterator<number>): number | null {\n\treturn foldl(a, null, min2);\n}\n\n/**\n * [max2 description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param left [description]\n * @param right [description]\n * @return [description]\n */\nfunction max2(left: number | null, right: number): number {\n\tif (left == null || right > left) {\n\t\treturn right;\n\n\t} else {\n\t\treturn left;\n\t}\n}\n\n/**\n * [max description]\n *\n * @ignore Exclude from docs\n * @todo Verify that this works correctly\n * @todo Description\n * @param a [description]\n * @return [description]\n */\nexport function max(a: Iterator<number>): number | null {\n\treturn foldl(a, null, max2);\n}\n\n\n/**\n * [join description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param iter [description]\n * @param separator [description]\n * @return [description]\n */\nexport function join(iter: Iterator<string>, separator: string = \"\"): string {\n\tlet first = true;\n\tlet init = \"\";\n\n\titer((value) => {\n\t\tif (first) {\n\t\t\tfirst = false;\n\n\t\t} else {\n\t\t\tinit += separator;\n\t\t}\n\n\t\tinit += value;\n\n\t\treturn true;\n\t});\n\n\treturn init;\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport class ListIterator<T extends IClone<T>> {\n\tprivate _listCopy!: Array<T>;\n\tprivate _create: () => T;\n\n\tpublic list: Iterable<T>;\n\n\t// flag specifies if iterator should create new list item if it is reqested for a nextItem but there is no more left in the list\n\tpublic createNewItems: boolean = false;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param list [description]\n\t * @param create [description]\n\t */\n\tconstructor(list: Iterable<T>, create: () => T) {\n\t\tthis.list = list;\n\t\tthis._create = create;\n\t\tthis.reset();\n\t}\n\n\treset() {\n\t\tthis._listCopy = toArray(this.list.iterator());\n\t}\n\n\tclear() {\n\t\tthis._listCopy.length = 0;\n\t}\n\n\tgetFirst(): $type.Optional<T> {\n\t\treturn this.returnItem(0);\n\t}\n\n\tgetLast(): $type.Optional<T> {\n\t\treturn this.returnItem(this._listCopy.length - 1);\n\t}\n\n\tfind(fn: (value: T) => boolean): $type.Optional<T> {\n\t\tlet index: number = $array.findIndex(this._listCopy, fn);\n\n\t\tif (index !== -1) {\n\t\t\tlet item = this._listCopy[index];\n\t\t\t// TODO use removeIndex instead ?\n\t\t\t$array.remove(this._listCopy, item);\n\t\t\treturn item;\n\n\t\t} else {\n\t\t\treturn this.getLast();\n\t\t}\n\t}\n\n\tremoveItem(item: T): boolean {\n\t\treturn $array.remove(this._listCopy, item);\n\t}\n\n\tprotected returnItem(index: number): $type.Optional<T> {\n\t\tif (index >= 0 && index < this._listCopy.length) {\n\t\t\tlet item = this._listCopy[index];\n\t\t\t// TODO use removeIndex instead ?\n\t\t\t$array.remove(this._listCopy, item);\n\t\t\treturn item;\n\n\t\t} else if (this.createNewItems) {\n\t\t\treturn this._create();\n\t\t}\n\t}\n\n\titerator() {\n\t\treturn fromArray(this._listCopy);\n\t}\n}\n","/**\n * ============================================================================\n * MAIN CLASS\n * ============================================================================\n * @hidden\n */\n\n/**\n * Represents a relative value (percent).\n *\n * The Percent object, can be instantiated using two ways:\n *\n * * Via `new Percent(X)`.\n * * Via `am4core.percent(X)`.\n *\n * `Percent` type objects can be used in a number of dual-measuring or\n * positioning properties, like `width`. E.g.:\n *\n * ```TypeScript\n * chart.paddingRight = new Percent(10);\n * // or\n * chart.paddingRight = am4core.percent(10);\n * ```\n * ```JavaScript\n * chart.paddingRight = new Percent(10);\n * // or\n * chart.paddingRight = am4core.percent(10);\n * ```\n * ```JSON\n * {\n *   // ...\n *   \"paddingRight\": \"10%\"\n * }\n * ```\n */\nexport class Percent {\n\n\t/**\n\t * Value in percent.\n\t */\n\tprotected _value: number;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @param percent  Percent value\n\t */\n\tconstructor(percent: number) {\n\t\tthis._value = percent;\n\t}\n\n\t/**\n\t * Relative value.\n\t *\n\t * E.g. 100% is 1, 50% is 0.5, etc.\n\t *\n\t * This is useful to apply transformations to other values. E.g.:\n\t *\n\t * ```TypeScript\n\t * let value = 256;\n\t * let percent = new am4core.Percent(50);\n\t * console.log(value * percent.value); // outputs 128\n\t * ```\n\t * ```JavaScript\n\t * var value = 256;\n\t * var percent = new am4core.Percent(50);\n\t * console.log(value * percent.value); // outputs 128\n\t * ```\n\t *\n\t * Alternatively, you can use `am4core.percent()` helper function:\n\t *\n\t * ```TypeScript\n\t * let value = 256;\n\t * let percent = am4core.percent(50);\n\t * console.log(value * percent.value); // outputs 128\n\t * ```\n\t * ```JavaScript\n\t * var value = 256;\n\t * var percent = am4core.percent(50);\n\t * console.log(value * percent.value); // outputs 128\n\t * ```\n\t *\n\t * @readonly\n\t * @return Relative value\n\t */\n\tpublic get value(): number {\n\t\treturn this._value / 100;\n\t}\n\n\t/**\n\t * Value in percent.\n\t *\n\t * @return Percent\n\t */\n\tpublic get percent(): number {\n\t\treturn this._value;\n\t}\n\n\tpublic toString(): string {\n\t\treturn \"\" + this._value + \"%\";\n\t}\n\n\t/*public toNumber(): number {\n\t\treturn this.percent;\n\t}*/\n\n}\n\n\n/**\n * Converts numeric percent value to a proper [[Percent]] object.\n *\n * ```TypeScript\n * pieSeries.radius = am4core.percent(80);\n * ```\n * ```JavaScript\n * pieSeries.radius = am4core.percent(80);\n * ```\n *\n * @param value  Percent\n * @return Percent object\n */\nexport function percent(value: number): Percent {\n\treturn new Percent(value);\n}\n\n\n/**\n * Checks if value is a [[Percent]] object.\n *\n * @ignore Exclude from docs\n * @param value  Input value\n * @return Is percent?\n */\nexport function isPercent(value: any): boolean {\n\treturn value instanceof Percent;\n}\n","/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport * as $array from \"./Array\";\r\nimport * as $iter from \"./Iterator\";\r\nimport * as $type from \"./Type\";\r\nimport { Ordering } from \"./Order\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * UTILITY FUNCTIONS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Returns an iterator for all entries in object.\r\n *\r\n * Can be used to safely iterate through all properties of the object.\r\n *\r\n * @param object  Source object\r\n * @returns Iterator\r\n */\r\nexport function entries<Object>(object: Object): $iter.Iterator<[$type.Keyof<Object>, Object[$type.Keyof<Object>]]> {\r\n\treturn (push) => {\r\n\t\t// TODO make this more efficient ?\r\n\t\tfor (let key in object) {\r\n\t\t\tif (hasKey(object, key)) {\r\n\t\t\t\tif (!push([key as $type.Keyof<Object>, object[key] as Object[$type.Keyof<Object>]])) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n * Returns an array of object's property names.\r\n *\r\n * @param object  Source object\r\n * @returns Object property names\r\n */\r\nexport function keys<Object>(object: Object): Array<$type.Keyof<Object>> {\r\n\tconst output = [];\r\n\r\n\tfor (let key in object) {\r\n\t\tif (hasKey(object, key)) {\r\n\t\t\toutput.push(key as $type.Keyof<Object>);\r\n\t\t}\r\n\t}\r\n\r\n\treturn output;\r\n}\r\n\r\n/**\r\n * Returns an array of object's property names ordered using specific ordering\r\n * function.\r\n *\r\n * @param object  Source object\r\n * @param order   Ordering function\r\n * @returns Object property names\r\n */\r\nexport function keysOrdered<Object>(object: Object, order: (a: $type.Keyof<Object>, b: $type.Keyof<Object>) => Ordering): Array<$type.Keyof<Object>> {\r\n\treturn keys(object).sort(order);\r\n}\r\n\r\n/**\r\n * Checks if `object` has a specific `key`.\r\n *\r\n * @param object  Source object\r\n * @param key     Property name\r\n * @returns Has key?\r\n */\r\nexport function hasKey<Object, Key extends keyof Object>(object: Object, key: Key): boolean {\r\n\treturn {}.hasOwnProperty.call(object, key);\r\n}\r\n\r\n/**\r\n * Returns value of the specific `key`.\r\n *\r\n * @param object  Source object\r\n * @param key     Property name\r\n * @returns Key value\r\n */\r\nexport function getKey<Object, Key extends keyof Object>(object: Object, key: Key): Object[Key] {\r\n\treturn object[key];\r\n}\r\n\r\n/**\r\n * Iterates through all properties of the object calling `fn` for each of them.\r\n *\r\n * If return value of the function evaluates to `false` further iteration is\r\n * cancelled.\r\n *\r\n * @param object  Source object\r\n * @param fn      Callback function\r\n */\r\nexport function eachContinue<Object>(object: Object, fn: <Key extends $type.Keyof<Object>>(key: Key, value: Object[Key]) => boolean): void {\r\n\tfor (let key in object) {\r\n\t\tif (hasKey(object, key)) {\r\n\t\t\tif (!fn(key as $type.Keyof<Object>, object[key] as Object[$type.Keyof<Object>])) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Iterates through all properties of the object calling `fn` for each of them.\r\n *\r\n * @param object  Source object\r\n * @param fn      Callback function\r\n */\r\nexport function each<Object>(object: Object, fn: <Key extends $type.Keyof<Object>>(key: Key, value: Object[Key]) => void): void {\r\n\teachContinue(object, (key, value) => {\r\n\t\tfn(key, value);\r\n\t\treturn true;\r\n\t});\r\n}\r\n\r\n/**\r\n * Orders object properties using custom `ord` function and iterates through\r\n * them calling `fn` for each of them.\r\n *\r\n * @param object  Source object\r\n * @param fn      Callback function\r\n * @param order   Ordering function\r\n */\r\nexport function eachOrdered<Object>(object: Object, fn: <Key extends $type.Keyof<Object>>(key: Key, value: Object[Key]) => void, ord: (a: $type.Keyof<Object>, b: $type.Keyof<Object>) => Ordering): void {\r\n\t$array.each(keysOrdered(object, ord), (key) => {\r\n\t\tfn(key, object[key]);\r\n\t});\r\n}\r\n\r\n/**\r\n * Returns a copy of the object.\r\n *\r\n * @param object  Source object\r\n * @returns Copy of the object\r\n */\r\nexport function copy<Object>(object: Object): Object {\r\n\treturn Object.assign({}, object);\r\n}\r\n\r\n/**\r\n * Merges two objects and returns a new object that contains properties from\r\n * both source objects.\r\n *\r\n * @param object1  Source object #1\r\n * @param object2  Source object #2\r\n * @returns Combined object\r\n */\r\nexport function merge<Object1, Object2>(object1: Object1, object2: Object2): Object1 & Object2 {\r\n\treturn Object.assign({}, object1, object2);\r\n}\r\n\r\n/**\r\n * Copies a list of properties from one object to another.\r\n *\r\n * Will not copy empty properties.\r\n *\r\n * @param source  Source object\r\n * @param target    Target object\r\n * @param keys  List of keys to copy\r\n */\r\nexport function copyProperties(source: { [key: string]: any }, target: { [key: string]: any }, keys: Array<string>): void {\r\n\t$array.each(keys, (key) => {\r\n\t\tif ($type.hasValue(source[key])) {\r\n\t\t\ttarget[key] = source[key];\r\n\t\t}\r\n\t});\r\n}\r\n\r\n/**\r\n * Copies a list of properties from one object to another only if target does't have value of the property set.\r\n *\r\n * Will not copy empty properties.\r\n *\r\n * @param source  Source object\r\n * @param target    Target object\r\n * @param keys  List of keys to copy\r\n */\r\nexport function softCopyProperties(source: { [key: string]: any }, target: { [key: string]: any }, keys: Array<string>): void {\r\n\t$array.each(keys, (key) => {\r\n\t\tif ($type.hasValue(source[key]) && !($type.hasValue((<any>target)[key]))) {\r\n\t\t\ttarget[key] = source[key];\r\n\t\t}\r\n\t});\r\n}\r\n\r\n/**\r\n * Copies a list of properties from one object to another.\r\n *\r\n * Will copy empty properties.\r\n *\r\n * @param source  Source object\r\n * @param target    Target object\r\n * @param keys  List of keys to copy\r\n */\r\nexport function forceCopyProperties(source: { [key: string]: any }, target: { [key: string]: any }, keys: Array<string>): void {\r\n\t$array.each(keys, (key) => {\r\n\t\ttarget[key] = source[key];\r\n\t});\r\n}\r\n\r\n/**\r\n * Copies all properties from one object to another.\r\n *\r\n * @param from  Source object\r\n * @param to    Target object\r\n */\r\nexport function copyAllProperties(from: { [key: string]: any }, to: { [key: string]: any }): void {\r\n\tcopyProperties(from, to, keys(from));\r\n}\r\n","/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { IDisposer, Disposer } from \"./Disposer\";\r\nimport { EventDispatcher, AMEvent } from \"./EventDispatcher\";\r\nimport { Optional } from \"./Type\";\r\nimport { IClone } from \"./Clone\";\r\nimport * as $object from \"./Object\";\r\nimport * as $iter from \"./Iterator\";\r\nimport * as $string from \"./String\";\r\n\r\n/**\r\n * Defines events from [[Dictionary]].\r\n */\r\nexport interface IDictionaryEvents<Key, Value> {\r\n\r\n\t/**\r\n\t * Invoked when an item is removed from the dictionary.\r\n\t */\r\n\tremoved: {\r\n\r\n\t\t/**\r\n\t\t * Removed value.\r\n\t\t */\r\n\t\toldValue: Value;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when dictionary is cleared.\r\n\t */\r\n\tcleared: {};\r\n\r\n\t/**\r\n\t * Invoked when `insertKey()` method is called.\r\n\t */\r\n\tinsertKey: {\r\n\r\n\t\t/**\r\n\t\t * Key.\r\n\t\t */\r\n\t\tkey: Key;\r\n\r\n\t\t/**\r\n\t\t * Added value.\r\n\t\t */\r\n\t\tnewValue: Value;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when `setKey()` method is called.\r\n\t */\r\n\tsetKey: {\r\n\r\n\t\t/**\r\n\t\t * Key.\r\n\t\t */\r\n\t\tkey: Key;\r\n\r\n\t\t/**\r\n\t\t * Removed value. (if overwriting)\r\n\t\t */\r\n\t\toldValue: Value;\r\n\r\n\t\t/**\r\n\t\t * Added value.\r\n\t\t */\r\n\t\tnewValue: Value;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when `removeKey()` method is called.\r\n\t */\r\n\tremoveKey: {\r\n\r\n\t\t/**\r\n\t\t * Key.\r\n\t\t */\r\n\t\tkey: Key;\r\n\r\n\t\t/**\r\n\t\t * Removed value.\r\n\t\t */\r\n\t\toldValue: Value;\r\n\r\n\t};\r\n\r\n}\r\n\r\n/**\r\n * [K description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Descirption\r\n */\r\nexport type DictionaryLike<K, A> = $iter.Iterable<[K, A]> & {\r\n\tevents: EventDispatcher<{ removed: { oldValue: A } }>;\r\n};\r\n\r\n/**\r\n * A disposable dictionary, which when disposed itself will call `dispose()`\r\n * method on all its items.\r\n */\r\nexport class DictionaryDisposer<K, A extends IDisposer> extends Disposer {\r\n\tconstructor(dict: DictionaryLike<K, A>) {\r\n\t\tconst disposer = dict.events.on(\"removed\", (x) => {\r\n\t\t\tx.oldValue.dispose();\r\n\t\t}, undefined, false);\r\n\r\n\t\tsuper(() => {\r\n\t\t\tdisposer.dispose();\r\n\r\n\t\t\t// TODO clear the dictionary ?\r\n\t\t\t$iter.each(dict.iterator(), (a) => {\r\n\t\t\t\tconst v = a[1];\r\n\t\t\t\tv.dispose();\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n}\r\n\r\n/**\r\n * A Dictionary is collection where values of some type can be mapped to\r\n * string keys.\r\n *\r\n * You might call it an \"associative list\" or \"associative array\".\r\n */\r\nexport class Dictionary<Key extends string, T> {\r\n\r\n\t/**\r\n\t * Key/value pairs\r\n\t */\r\n\tprivate _dictionary: { [key in Key]?: T };\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t */\r\n\tpublic events: EventDispatcher<AMEvent<Dictionary<Key, T>, IDictionaryEvents<Key, T>>> = new EventDispatcher();\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tthis._dictionary = {};\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if key exists in Dictionary.\r\n\t *\r\n\t * @param key  The key to search for\r\n\t * @return `true` if key exists, `false` if it doesn't\r\n\t */\r\n\tpublic hasKey(key: Key): boolean {\r\n\t\treturn $object.hasKey(this._dictionary, key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the value for a specific key.\r\n\t *\r\n\t * @param key  The key to search for\r\n\t * @return Value for the key, or `undefined` if it doesn't exist\r\n\t */\r\n\tpublic getKey(key: Key): Optional<T> {\r\n\t\treturn this._dictionary[key];\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts value at specific key.\r\n\t *\r\n\t * Will thrown an exception if the key already exists in the dictionary.\r\n\t *\r\n\t * @param key    Key\r\n\t * @param value  Value\r\n\t */\r\n\tpublic insertKey(key: Key, value: T): void {\r\n\t\tif ($object.hasKey(this._dictionary, key)) {\r\n\t\t\tthrow new Error(\"Key \" + key + \" already exists in dictionary\");\r\n\r\n\t\t} else {\r\n\t\t\tthis._dictionary[key] = value;\r\n\r\n\t\t\tif (this.events.isEnabled(\"insertKey\")) {\r\n\t\t\t\tthis.events.dispatchImmediately(\"insertKey\", {\r\n\t\t\t\t\ttype: \"insertKey\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tkey: key,\r\n\t\t\t\t\tnewValue: value\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds or updates key/value into dictionary.\r\n\t *\r\n\t * If the key already exists, the old value will be overwritten.\r\n\t *\r\n\t * If the new value is exactly the same as the old value (using ===), it won't do anything.\r\n\t *\r\n\t * @param key    Key\r\n\t * @param value  Value\r\n\t */\r\n\tpublic setKey(key: Key, value: T): void {\r\n\t\tif ($object.hasKey(this._dictionary, key)) {\r\n\t\t\tconst oldValue = this._dictionary[key];\r\n\r\n\t\t\tif (oldValue !== value) {\r\n\t\t\t\tthis._dictionary[key] = value;\r\n\r\n\t\t\t\tif (this.events.isEnabled(\"setKey\")) {\r\n\t\t\t\t\tthis.events.dispatchImmediately(\"setKey\", {\r\n\t\t\t\t\t\ttype: \"setKey\",\r\n\t\t\t\t\t\ttarget: this,\r\n\t\t\t\t\t\tkey: key,\r\n\t\t\t\t\t\toldValue: oldValue,\r\n\t\t\t\t\t\tnewValue: value\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.events.isEnabled(\"removed\")) {\r\n\t\t\t\t\tthis.events.dispatchImmediately(\"removed\", {\r\n\t\t\t\t\t\ttype: \"removed\",\r\n\t\t\t\t\t\ttarget: this,\r\n\t\t\t\t\t\toldValue: oldValue\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tthis._dictionary[key] = value;\r\n\r\n\t\t\tif (this.events.isEnabled(\"insertKey\")) {\r\n\t\t\t\tthis.events.dispatchImmediately(\"insertKey\", {\r\n\t\t\t\t\ttype: \"insertKey\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tkey: key,\r\n\t\t\t\t\tnewValue: value\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates the value at specific `key` using custom function.\r\n\t *\r\n\t * Passes in current value into the function, and uses its output as a new\r\n\t * value.\r\n\t *\r\n\t * If the new value is exactly the same as the old value (using ===), it won't do anything.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param key  Key\r\n\t * @param fn   Function to transform the value\r\n\t */\r\n\tpublic updateKey(key: Key, fn: (value: T) => T): void {\r\n\t\tif ($object.hasKey(this._dictionary, key)) {\r\n\t\t\tconst oldValue = this._dictionary[key];\r\n\t\t\tconst newValue = fn(oldValue);\r\n\r\n\t\t\tif (oldValue !== newValue) {\r\n\t\t\t\tthis._dictionary[key] = newValue;\r\n\r\n\t\t\t\tif (this.events.isEnabled(\"setKey\")) {\r\n\t\t\t\t\tthis.events.dispatchImmediately(\"setKey\", {\r\n\t\t\t\t\t\ttype: \"setKey\",\r\n\t\t\t\t\t\ttarget: this,\r\n\t\t\t\t\t\tkey: key,\r\n\t\t\t\t\t\toldValue: oldValue,\r\n\t\t\t\t\t\tnewValue: newValue\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.events.isEnabled(\"removed\")) {\r\n\t\t\t\t\tthis.events.dispatchImmediately(\"removed\", {\r\n\t\t\t\t\t\ttype: \"removed\",\r\n\t\t\t\t\t\ttarget: this,\r\n\t\t\t\t\t\toldValue: oldValue\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Key \" + key + \" doesn't exist in dictionary\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Removes value at specific `key` from dictionary.\r\n\t *\r\n\t * @param key  Key to remove\r\n\t */\r\n\tpublic removeKey(key: Key): void {\r\n\t\tif ($object.hasKey(this._dictionary, key)) {\r\n\t\t\tconst oldValue = this._dictionary[key];\r\n\r\n\t\t\tdelete this._dictionary[key];\r\n\r\n\t\t\tif (this.events.isEnabled(\"removeKey\")) {\r\n\t\t\t\tthis.events.dispatchImmediately(\"removeKey\", {\r\n\t\t\t\t\ttype: \"removeKey\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tkey: key,\r\n\t\t\t\t\toldValue: oldValue\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (this.events.isEnabled(\"removed\")) {\r\n\t\t\t\tthis.events.dispatchImmediately(\"removed\", {\r\n\t\t\t\t\ttype: \"removed\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\toldValue: oldValue\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [insertKeyIfEmpty description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo description\r\n\t * @param key      [description]\r\n\t * @param ifEmpty  [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic insertKeyIfEmpty(key: Key, ifEmpty: () => T): T {\r\n\t\tif (!this.hasKey(key)) {\r\n\t\t\tthis.insertKey(key, ifEmpty());\r\n\t\t}\r\n\r\n\t\treturn <T>this.getKey(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes all items from the dictionary.\r\n\t */\r\n\tpublic clear(): void {\r\n\t\t// TODO dispatch this after clear\r\n\t\tif (this.events.isEnabled(\"removed\")) {\r\n\t\t\t$object.each(this._dictionary, (key, value) => {\r\n\t\t\t\tthis.events.dispatchImmediately(\"removed\", {\r\n\t\t\t\t\ttype: \"removed\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\toldValue: value\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis._dictionary = {};\r\n\r\n\t\tif (this.events.isEnabled(\"cleared\")) {\r\n\t\t\tthis.events.dispatchImmediately(\"cleared\", {\r\n\t\t\t\ttype: \"cleared\",\r\n\t\t\t\ttarget: this\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Copies items from another Dictionary.\r\n\t *\r\n\t * @param source  A Dictionary to copy items from\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\t$iter.each(source.iterator(), (a) => {\r\n\t\t\t// TODO fix this type cast\r\n\t\t\tthis.setKey(<Key>a[0], a[1]);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an interator that can be used to iterate through all items in\r\n\t * the dictionary.\r\n\t *\r\n\t * @return Iterator\r\n\t */\r\n\tpublic iterator(): $iter.Iterator<[Key, T]> {\r\n\t\t// @todo fix this type after the Iterator bug is fixed\r\n\t\t// https://github.com/Microsoft/TypeScript/issues/16730\r\n\t\treturn <$iter.Iterator<[Key, T]>>$object.entries(this._dictionary);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an ES6 iterator for the keys/values of the dictionary.\r\n\t */\r\n\tpublic *[Symbol.iterator](): Iterator<[Key, T]> {\r\n\t\t// TODO make this more efficient ?\r\n\t\tfor (let key in this._dictionary) {\r\n\t\t\tif ($object.hasKey(this._dictionary, key)) {\r\n\t\t\t\tyield [<Key>key, this._dictionary[key]];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Calls `f` for each key/value in the dictionary.\r\n\t */\r\n\tpublic each(f: (key: Key, value: T) => void): void {\r\n\t\t$iter.each(this.iterator(), ([key, value]) => f(key, value));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an iterator that can be used to iterate through all items in\r\n\t * the dictionary, ordered by key.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Iterator\r\n\t */\r\n\tpublic sortedIterator(): $iter.Iterator<[Key, T]> {\r\n\t\treturn $iter.sort(this.iterator(), (x, y) => $string.order(x[0], y[0]));\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * A version of a [[Dictionary]] that has a \"template\".\r\n *\r\n * A template is an instance of an object, that can be used to create new\r\n * elements in the list without actually needing to create instances for those.\r\n *\r\n * When new element is created in the list, e.g. by calling its `create()`\r\n * method, an exact copy of the element is created (including properties and\r\n * other attributes), inserted into the list and returned.\r\n */\r\nexport class DictionaryTemplate<Key extends string, T extends IClone<T> & { isTemplate: boolean }> extends Dictionary<Key, T> {\r\n\t/**\r\n\t * A template object.\r\n\t *\r\n\t * @todo Make this private\r\n\t */\r\n\tpublic _template!: T;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t *\r\n\t * @param t Template object\r\n\t */\r\n\tpublic constructor(t: T) {\r\n\t\tsuper();\r\n\t\tthis.template = t;\r\n\t}\r\n\r\n\t/**\r\n\t * A \"template\" object to copy all properties from when creating new list\r\n\t * items.\r\n\t *\r\n\t * @param v  Template object\r\n\t */\r\n\tpublic set template(v: T) {\r\n\t\tv.isTemplate = true;\r\n\t\tthis._template = v;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Template object\r\n\t */\r\n\tpublic get template(): T {\r\n\t\treturn this._template;\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all elements from other dictionary.\r\n\t *\r\n\t * @param source  Source dictionary\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\t$iter.each(source.iterator(), (a) => {\r\n\t\t\t// TODO fix this type cast\r\n\t\t\t// TODO why does this need to clone ?\r\n\t\t\tthis.setKey(<Key>a[0], a[1].clone());\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Instantiates a new object of the specified type, adds it to specified\r\n\t * `key` in the dictionary, and returns it.\r\n\t *\r\n\t * @param make  Item type to use. Will use the default type for the dictionary if not specified.\r\n\t * @return      Newly created item\r\n\t */\r\n\tpublic create(key: Key): T {\r\n\t\treturn this.insertKeyIfEmpty(key, () => this.template.clone());\r\n\t}\r\n\r\n}\r\n","/**\r\n * A collection of low-level async operation stuff.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport * as $array from \"./Array\";\r\n\r\n/**\r\n * [Listener description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nexport type Listener = (now: number) => void;\r\n\r\nlet pendingFrame = false;\r\n\r\nconst nextQueue: Array<Listener> = [];\r\nconst readQueue: Array<Listener> = [];\r\nconst writeQueue: Array<Listener> = [];\r\nconst idleQueue: Array<Listener> = [];\r\n\r\n\r\nconst fps = 1000 / 60;\r\n\r\n/**\r\n * [raf description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nexport const raf =\r\n\t(typeof requestAnimationFrame === \"function\"\r\n\t\t? function(fn: () => void): void {\r\n\t\t\trequestAnimationFrame(fn);\r\n\t\t}\r\n\t\t: function(fn: () => void): void {\r\n\t\t\tsetTimeout(fn, fps);\r\n\t\t});\r\n\r\n/**\r\n * [frameLoop description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nfunction frameLoop(): void {\r\n\tconst now = Date.now();\r\n\r\n\r\n\tconst length = nextQueue.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\tnextQueue[i](now);\r\n\t}\r\n\r\n\t$array.shiftLeft(nextQueue, length);\r\n\r\n\r\n\tfor (let i = 0; i < readQueue.length; ++i) {\r\n\t\treadQueue[i](now);\r\n\t}\r\n\r\n\treadQueue.length = 0;\r\n\r\n\r\n\tfor (let i = 0; i < writeQueue.length; ++i) {\r\n\t\twriteQueue[i](now);\r\n\t}\r\n\r\n\twriteQueue.length = 0;\r\n\r\n\r\n\tif (nextQueue.length === 0 && readQueue.length === 0) {\r\n\t\tpendingFrame = false;\r\n\r\n\t} else {\r\n\t\traf(frameLoop);\r\n\t}\r\n}\r\n\r\n/**\r\n * [pendFrame description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nfunction pendFrame(): void {\r\n\tif (!pendingFrame) {\r\n\t\tpendingFrame = true;\r\n\r\n\t\traf(frameLoop);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * [nextFrame description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param fn [description]\r\n */\r\nexport function nextFrame(fn: Listener): void {\r\n\tnextQueue.push(fn);\r\n\tpendFrame();\r\n}\r\n\r\n/**\r\n * [readFrame description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param fn [description]\r\n */\r\nexport function readFrame(fn: Listener): void {\r\n\treadQueue.push(fn);\r\n\tpendFrame();\r\n}\r\n\r\n/**\r\n * [writeFrame description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param fn [description]\r\n */\r\nexport function writeFrame(fn: Listener): void {\r\n\twriteQueue.push(fn);\r\n\tpendFrame();\r\n}\r\n\r\n/**\r\n * [whenIdle description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param fn [description]\r\n */\r\nexport function whenIdle(fn: Listener): void {\r\n\tidleQueue.push(fn);\r\n}\r\n\r\n/**\r\n * [triggerIdle description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @todo Maybe don't trigger a callback which was added while in the middle of triggering?\r\n */\r\nexport function triggerIdle(): void {\r\n\tconst now = Date.now();\r\n\r\n\tconst length = idleQueue.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\t(<any>idleQueue.shift())(now);\r\n\t}\r\n}\r\n"],"sourceRoot":""}