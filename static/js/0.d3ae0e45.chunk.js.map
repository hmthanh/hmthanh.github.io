{"version":3,"sources":["../../../../../src/.internal/core/utils/AsyncPending.ts","../../../../../src/.internal/core/utils/EventDispatcher.ts","../../../../../src/.internal/core/utils/String.ts","../../../../../src/.internal/core/utils/Cache.ts","../node_modules/tslib/tslib.es6.js","../../../../../src/.internal/core/Registry.ts","../../../../../src/.internal/core/utils/Type.ts","../../../../../src/.internal/core/utils/Math.ts","../../../../../src/.internal/core/utils/Array.ts","../../../../../src/.internal/core/utils/Disposer.ts","../../../../../src/.internal/core/utils/Iterator.ts","../../../../../src/.internal/core/utils/Percent.ts","../../../../../src/.internal/core/utils/Object.ts","../../../../../src/.internal/core/utils/Dictionary.ts"],"names":["pendingFrame","nextQueue","readQueue","writeQueue","idleQueue","raf","requestAnimationFrame","fn","setTimeout","frameLoop","now","Date","length","i","pendFrame","nextFrame","push","readFrame","writeFrame","whenIdle","triggerIdle","shift","this","_listeners","_killed","_disabled","_iterating","_enabled","_disposed","isDisposed","dispose","a","x","disposer","hasListeners","hasListenersByType","type","enable","disable","enableType","disableType","amount","_removeListener","listener","index","indexOf","Error","splice","_removeExistingListener","once","callback","context","_eachListener","info","isEnabled","has","_shouldDispatch","count","killed","dispatchImmediately","event","dispatch","_on","shouldClone","onAll","call","on","off","copyFrom","source","target","EventDispatcher","order","b","repeat","string","Array","join","random","chars","res","choice","charAt","Math","floor","_storage","ttl","set","owner","key","value","ownerStorage","insertKeyIfEmpty","item","getTime","setKey","get","hasKey","getKey","cacheItem","touched","expired","removeKey","clear","cache","Cache","extendStatics","d","Object","setPrototypeOf","__proto__","p","prototype","hasOwnProperty","__extends","__","constructor","create","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","Symbol","iterator","n","v","op","TypeError","pop","__values","o","s","m","__read","r","ar","error","__spread","arguments","concat","events","themes","loadedThemes","_uidCount","registeredClasses","_placeholders","invalidSprites","invalidDatas","invalidRawDatas","invalidDataItems","invalidDataRange","invalidPositions","invalidLayouts","baseSprites","baseSpritesByUid","queue","deferred","uid","getUniqueId","noBase","addEventListener","sprite","svg","paper","setAttribute","clientWidth","clientHeight","removeAttribute","_map","setCache","getCache","eventType","data","getPlaceholder","addToInvalidComponents","component","baseId","removeFromInvalidComponents","addToInvalidSprites","removeFromInvalidSprites","addToInvalidPositions","removeFromInvalidPositions","addToInvalidLayouts","removeFromInvalidLayouts","registry","Registry","is","object","name","isNaN","Number","getType","toString","getDefault","optional","checkString","checkBoolean","checkNumber","checkObject","checkArray","isArray","checkDate","castString","castNumber","number","JSON","stringify","toBoolean","toNumber","hasValue","isNumber","converted","isString","replace","toText","isObject","toNumberOrPercent","getValue","getValueDefault","defaultValue","isDate","PI","HALFPI","RADIANS","DEGREES","toNumberRange","min","max","fitToRange","round","precision","rounded","pow","ceil","stretch","from","to","minValue","maxValue","temp","sin","tan","cos","left","right","closest","values","referenceValue","reduce","prev","curr","abs","intersect","range1","range2","start1","start","start2","end1","end","end2","invertRange","range","intersection","startMax","endMin","getDistance","point1","point2","sqrt","getHorizontalDistance","getVerticalDistance","getCubicCurveDistance","controlPointA","controlPointB","stepCount","distance","prevPoint","point","getPointOnCubicCurve","getScale","startPoint1","startPoint2","initialDistance","currentDistance","getMidPoint","position","getRotation","diff","getAngle","diffX","diffY","angle","atan2","normalizeAngle","getCenterShift","center","getBBox","points","bottom","width","height","getCommonRectangle","rectangles","minX","minY","maxX","maxY","rectangle","getPointOnQuadraticCurve","pointA","pointB","controlPoint","mt1","mt2","mt3","getCubicControlPointA","p0","p1","p2","p3","tensionX","tensionY","adjustTension","getCubicControlPointB","tension","fitAngleToRange","startAngle","endAngle","getArcRect","radius","MAX_VALUE","bpoints","getArcPoint","fromAngle","toAngle","pt","arc","isInRectangle","getLineIntersection","pointA1","pointA2","pointB1","pointB2","array","any","test","map","output","each","eachReverse","eachContinue","shiftLeft","last","undefined","first","insert","element","setIndex","remove","pushAll","input","found","move","toIndex","removeIndex","insertIndex","add","unshift","ind","toArray","copy","slice","getSortedIndex","ordering","pivot","findIndex","matches","find","shuffle","temporaryValue","randomIndex","currentIndex","keepIf","keep","_dispose","disposers","Disposer","_disposer","_value","reset","_counter","increment","fromArray","iter","sum","sort","filter","go","push2","args","flatten","indexed","findMap","contains","foldl","init","min2","max2","separator","list","createNewItems","_create","_listCopy","getFirst","returnItem","getLast","removeItem","percent","Percent","isPercent","entries","keys","keysOrdered","eachOrdered","ord","assign","merge","object1","object2","clone","parse","copyProperties","softCopyProperties","forceCopyProperties","copyAllProperties","dict","oldValue","_dictionary","insertKey","newValue","updateKey","ifEmpty","sortedIterator","template","_template","isTemplate","Dictionary"],"mappings":"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","file":"static/js/0.d3ae0e45.chunk.js","sourcesContent":["/**\r\n * A collection of low-level async operation stuff.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport * as $array from \"./Array\";\r\n\r\n/**\r\n * [Listener description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nexport type Listener = (now: number) => void;\r\n\r\nlet pendingFrame = false;\r\n\r\nconst nextQueue: Array<Listener> = [];\r\nconst readQueue: Array<Listener> = [];\r\nconst writeQueue: Array<Listener> = [];\r\nconst idleQueue: Array<Listener> = [];\r\n\r\n\r\nconst fps = 1000 / 60;\r\n\r\n/**\r\n * [raf description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nexport const raf =\r\n\t(typeof requestAnimationFrame === \"function\"\r\n\t\t? function(fn: () => void): void {\r\n\t\t\trequestAnimationFrame(fn);\r\n\t\t}\r\n\t\t: function(fn: () => void): void {\r\n\t\t\tsetTimeout(fn, fps);\r\n\t\t});\r\n\r\n/**\r\n * [frameLoop description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nfunction frameLoop(): void {\r\n\tconst now = Date.now();\r\n\r\n\r\n\tconst length = nextQueue.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\tnextQueue[i](now);\r\n\t}\r\n\r\n\t$array.shiftLeft(nextQueue, length);\r\n\r\n\r\n\tfor (let i = 0; i < readQueue.length; ++i) {\r\n\t\treadQueue[i](now);\r\n\t}\r\n\r\n\treadQueue.length = 0;\r\n\r\n\r\n\tfor (let i = 0; i < writeQueue.length; ++i) {\r\n\t\twriteQueue[i](now);\r\n\t}\r\n\r\n\twriteQueue.length = 0;\r\n\r\n\r\n\tif (nextQueue.length === 0 && readQueue.length === 0) {\r\n\t\tpendingFrame = false;\r\n\r\n\t} else {\r\n\t\traf(frameLoop);\r\n\t}\r\n}\r\n\r\n/**\r\n * [pendFrame description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nfunction pendFrame(): void {\r\n\tif (!pendingFrame) {\r\n\t\tpendingFrame = true;\r\n\r\n\t\traf(frameLoop);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * [nextFrame description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param fn [description]\r\n */\r\nexport function nextFrame(fn: Listener): void {\r\n\tnextQueue.push(fn);\r\n\tpendFrame();\r\n}\r\n\r\n/**\r\n * [readFrame description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param fn [description]\r\n */\r\nexport function readFrame(fn: Listener): void {\r\n\treadQueue.push(fn);\r\n\tpendFrame();\r\n}\r\n\r\n/**\r\n * [writeFrame description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param fn [description]\r\n */\r\nexport function writeFrame(fn: Listener): void {\r\n\twriteQueue.push(fn);\r\n\tpendFrame();\r\n}\r\n\r\n/**\r\n * [whenIdle description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param fn [description]\r\n */\r\nexport function whenIdle(fn: Listener): void {\r\n\tidleQueue.push(fn);\r\n}\r\n\r\n/**\r\n * [triggerIdle description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @todo Maybe don't trigger a callback which was added while in the middle of triggering?\r\n */\r\nexport function triggerIdle(): void {\r\n\tconst now = Date.now();\r\n\r\n\tconst length = idleQueue.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\t(<any>idleQueue.shift())(now);\r\n\t}\r\n}\r\n","/**\r\n * Event Dispatcher module is used for registering listeners and dispatching\r\n * events across amCharts system.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Disposer, IDisposer } from \"./Disposer\";\r\nimport * as $array from \"./Array\";\r\nimport * as $async from \"./AsyncPending\";\r\nimport * as $type from \"./Type\";\r\n\r\n/**\r\n * Defines a universal type for the event object.\r\n */\r\nexport type AMEvent<Target, T> = {\r\n\t[K in keyof T]: { type: K, target: Target } & T[K];\r\n};\r\n\r\n/**\r\n * A universal interface for event listeners.\r\n */\r\nexport interface EventListener<T> {\r\n\tkilled: boolean;\r\n\tonce: boolean;\r\n\ttype: any;\r\n\tcallback: any;\r\n\tcontext: any;\r\n\tshouldClone: boolean;\r\n\tdispatch: any;\r\n\tdisposer: IDisposer;\r\n}\r\n\r\n/*export interface IEventDispatcher<T> {\r\n\tisDisposed(): boolean;\r\n\tdispose(): void;\r\n\thasListeners(): boolean;\r\n\tenable(): void;\r\n\tdisable(): void;\r\n\tenableType<Key extends keyof T>(type: Key): void;\r\n\tdisableType<Key extends keyof T>(type: Key, amount?: number): void;\r\n\tisEnabled<Key extends keyof T>(type: Key): boolean;\r\n\thas<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean;\r\n\tdispatchImmediately<Key extends keyof T>(type: Key, event: T[Key]): void;\r\n\tdispatch<Key extends keyof T>(type: Key, event: T[Key]): void;\r\n\tonAll<C, Key extends keyof T>(callback: (this: C, type: Key, event: T[Key]) => void, context?: C): IDisposer;\r\n\ton<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;\r\n\tonce<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;\r\n\toff<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;\r\n\toff<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;\r\n\tcopyFrom(source: this): void;\r\n}*/\r\n\r\n/**\r\n * Universal Event Dispatcher.\r\n *\r\n * @important\r\n */\r\nexport class EventDispatcher<T> implements IDisposer {\r\n\r\n\tprotected _listeners: Array<EventListener<T>>;\r\n\tprotected _killed: Array<EventListener<T>>;\r\n\tprotected _disabled: { [key in keyof T]?: number };\r\n\tprotected _iterating: number;\r\n\tprotected _enabled: boolean;\r\n\tprotected _disposed: boolean;\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tthis._listeners = [];\r\n\t\tthis._killed = [];\r\n\t\tthis._disabled = {};\r\n\t\tthis._iterating = 0;\r\n\t\tthis._enabled = true;\r\n\t\tthis._disposed = false;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns if this object has been already disposed.\r\n\t *\r\n\t * @return Disposed?\r\n\t */\r\n\tpublic isDisposed(): boolean {\r\n\t\treturn this._disposed;\r\n\t}\r\n\r\n\t/**\r\n\t * Dispose (destroy) this object.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tif (!this._disposed) {\r\n\t\t\tthis._disposed = true;\r\n\r\n\t\t\tconst a = this._listeners;\r\n\r\n\t\t\tthis._iterating = 1;\r\n\t\t\tthis._listeners = <any>null;\r\n\t\t\tthis._disabled = <any>null;\r\n\r\n\t\t\ttry {\r\n\t\t\t\t$array.each(a, (x) => {\r\n\t\t\t\t\tx.disposer.dispose();\r\n\t\t\t\t});\r\n\r\n\t\t\t} finally {\r\n\t\t\t\tthis._killed = <any>null;\r\n\t\t\t\tthis._iterating = <any>null;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this particular event dispatcher has any listeners set.\r\n\t *\r\n\t * @return Has listeners?\r\n\t */\r\n\tpublic hasListeners(): boolean {\r\n\t\treturn this._listeners.length !== 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this particular event dispatcher has any particular listeners set.\r\n\t *\r\n\t * @return Has particular event listeners?\r\n\t */\r\n\tpublic hasListenersByType<Key extends keyof T>(type: Key): boolean {\r\n\t\treturn $array.any(this._listeners, (x) => (x.type === null || x.type === type) && !x.killed);\r\n\t}\r\n\r\n\t/**\r\n\t * Enable dispatching of events if they were previously disabled by\r\n\t * `disable()`.\r\n\t */\r\n\tpublic enable(): void {\r\n\t\tthis._enabled = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Disable dispatching of events until re-enabled by `enable()`.\r\n\t */\r\n\tpublic disable(): void {\r\n\t\tthis._enabled = false;\r\n\t}\r\n\r\n\t/**\r\n\t * Enable dispatching particular event, if it was disabled before by\r\n\t * `disableType()`.\r\n\t *\r\n\t * @param type Event type\r\n\t */\r\n\tpublic enableType<Key extends keyof T>(type: Key): void {\r\n\t\tdelete this._disabled[type];\r\n\t}\r\n\r\n\t/**\r\n\t * Disable dispatching of events for a certain event type.\r\n\t *\r\n\t * Optionally, can set how many dispatches to skip before automatically\r\n\t * re-enabling the dispatching.\r\n\t *\r\n\t * @param type    Event type\r\n\t * @param amount  Number of event dispatches to skip\r\n\t */\r\n\tpublic disableType<Key extends keyof T>(type: Key, amount: number = Infinity): void {\r\n\t\tthis._disabled[type] = amount;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes listener from dispatcher.\r\n\t *\r\n\t * Will throw an exception if such listener does not exists.\r\n\t *\r\n\t * @param listener Listener to remove\r\n\t */\r\n\tprotected _removeListener(listener: EventListener<T>): void {\r\n\t\tif (this._iterating === 0) {\r\n\t\t\tconst index = this._listeners.indexOf(listener);\r\n\r\n\t\t\tif (index === -1) {\r\n\t\t\t\tthrow new Error(\"Invalid state: could not remove listener\");\r\n\t\t\t}\r\n\r\n\t\t\tthis._listeners.splice(index, 1);\r\n\r\n\t\t} else {\r\n\t\t\tthis._killed.push(listener);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Removes existing listener by certain parameters.\r\n\t *\r\n\t * @param once         Listener's once setting\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t */\r\n\tprotected _removeExistingListener<A, B, Key extends keyof T>(once: boolean, type: Key | null, callback?: A, context?: B): void {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tthis._eachListener((info) => {\r\n\t\t\tif (info.once === once && // TODO is this correct ?\r\n\t\t\t\tinfo.type === type &&\r\n\t\t\t\t(callback == null || info.callback === callback) &&\r\n\t\t\t\tinfo.context === context) {\r\n\t\t\t\tinfo.disposer.dispose();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if dispatching for particular event type is enabled.\r\n\t *\r\n\t * @param type  Event type\r\n\t * @return Enabled?\r\n\t */\r\n\tpublic isEnabled<Key extends keyof T>(type: Key): boolean {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\t// TODO is this check correct ?\r\n\t\treturn this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] == null;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if there's already a listener with specific parameters.\r\n\t *\r\n\t * @param type      Listener's type\r\n\t * @param callback  Callback function\r\n\t * @param context   Callback context\r\n\t * @return Has listener?\r\n\t */\r\n\tpublic has<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean {\r\n\t\tconst index = $array.findIndex(this._listeners, (info) => {\r\n\t\t\treturn info.once !== true && // Ignoring \"once\" listeners\r\n\t\t\t\tinfo.type === type &&\r\n\t\t\t\t(callback == null || info.callback === callback) &&\r\n\t\t\t\tinfo.context === context;\r\n\t\t});\r\n\r\n\t\treturn index !== -1;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether event of the particular type should be dispatched.\r\n\t *\r\n\t * @param type  Event type\r\n\t * @return Dispatch?\r\n\t */\r\n\tprotected _shouldDispatch<Key extends keyof T>(type: Key): boolean {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tconst count = this._disabled[type];\r\n\r\n\t\tif (!$type.isNumber(count)) {\r\n\t\t\treturn this._enabled;\r\n\r\n\t\t} else {\r\n\t\t\tif (count <= 1) {\r\n\t\t\t\tdelete this._disabled[type];\r\n\r\n\t\t\t} else {\r\n\t\t\t\t--this._disabled[type];\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [_eachListener description]\r\n\t *\r\n\t * All of this extra code is needed when a listener is removed while iterating\r\n\t *\r\n\t * @todo Description\r\n\t * @param fn [description]\r\n\t */\r\n\tprotected _eachListener(fn: (listener: EventListener<T>) => void): void {\r\n\t\t++this._iterating;\r\n\r\n\t\ttry {\r\n\t\t\t$array.each(this._listeners, fn);\r\n\r\n\t\t} finally {\r\n\t\t\t--this._iterating;\r\n\r\n\t\t\t// TODO should this be inside or outside the finally ?\r\n\t\t\tif (this._iterating === 0 && this._killed.length !== 0) {\r\n\t\t\t\t// Remove killed listeners\r\n\t\t\t\t$array.each(this._killed, (killed) => {\r\n\t\t\t\t\tthis._removeListener(killed);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis._killed.length = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Dispatches an event immediately without waiting for next cycle.\r\n\t *\r\n\t * @param type   Event type\r\n\t * @param event  Event object\r\n\t * @todo automatically add in type and target properties if they are missing\r\n\t */\r\n\tpublic dispatchImmediately<Key extends keyof T>(type: Key, event: T[Key]): void {\r\n\t\tif (this._shouldDispatch(type)) {\r\n\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\r\n\t\t\t// TODO if the function throws, maybe it should keep going ?\r\n\t\t\tthis._eachListener((listener) => {\r\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\r\n\t\t\t\t\tlistener.dispatch(type, event);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Shelves the event to be dispatched within next update cycle.\r\n\t *\r\n\t * @param type   Event type\r\n\t * @param event  Event object\r\n\t * @todo automatically add in type and target properties if they are missing\r\n\t */\r\n\tpublic dispatch<Key extends keyof T>(type: Key, event: T[Key]): void {\r\n\t\tif (this._shouldDispatch(type)) {\r\n\t\t\tthis._eachListener((listener) => {\r\n\t\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\r\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\r\n\t\t\t\t\t// TODO if the function throws, maybe it should keep going ?\r\n\t\t\t\t\t// TODO dispatch during the update cycle, rather than using whenIdle\r\n\t\t\t\t\t$async.whenIdle(() => {\r\n\t\t\t\t\t\tif (!listener.killed) {\r\n\t\t\t\t\t\t\tlistener.dispatch(type, event);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Creates, catalogs and returns an [[EventListener]].\r\n\t *\r\n\t * Event listener can be disposed.\r\n\t *\r\n\t * @param once         Listener's once setting\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @param dispatch\r\n\t * @returns An event listener\r\n\t */\r\n\tprotected _on<A, B, Key extends keyof T>(once: boolean, type: Key | null, callback: A, context: B, shouldClone: boolean, dispatch: (type: Key, event: T[Key]) => void): EventListener<T> {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tthis._removeExistingListener(once, type, callback, context);\r\n\r\n\t\tconst info: EventListener<T> = {\r\n\t\t\ttype: type,\r\n\t\t\tcallback: callback,\r\n\t\t\tcontext: context,\r\n\t\t\tshouldClone: shouldClone,\r\n\t\t\tdispatch: <any>dispatch,\r\n\t\t\tkilled: false,\r\n\t\t\tonce: once,\r\n\t\t\tdisposer: new Disposer(() => {\r\n\t\t\t\tinfo.killed = true;\r\n\t\t\t\tthis._removeListener(info);\r\n\t\t\t})\r\n\t\t};\r\n\r\n\t\tthis._listeners.push(info);\r\n\r\n\t\treturn info;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an event listener to be invoked on **any** event.\r\n\t *\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @returns A disposable event listener\r\n\t * @todo what if `listen` is called on the same function twice ?\r\n\t */\r\n\tpublic onAll<C, Key extends keyof T>(callback: (this: C, type: Key, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\r\n\t\treturn this._on(false, null, callback, context, shouldClone, (type, event) => callback.call(context, type, event)).disposer;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an event listener to be invoked on a specific event type.\r\n\t *\r\n\t * ```TypeScript\r\n\t * series.events.on(\"hidden\", (ev) => {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * series.events.on(\"hidden\", function(ev) {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"series\": [{\r\n\t *     // ...\r\n\t *     \"events\": {\r\n\t *     \t\"hidden\": function(ev) {\r\n\t *     \t  console.log(\"Series hidden: \" + ev.target.name);\r\n\t *     \t}\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * The above will invoke our custom event handler whenever series we put\r\n\t * event on is hidden.\r\n\t *\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @returns A disposable event listener\r\n\t * @todo what if `listen` is called on the same function twice ?\r\n\t */\r\n\tpublic on<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\r\n\t\treturn this._on(false, type, callback, context, shouldClone, (type, event) => callback.call(context, event)).disposer;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an event listener to be invoked on a specific event type once.\r\n\t *\r\n\t * Once the event listener is invoked, it is automatically disposed.\r\n\t *\r\n\t * ```TypeScript\r\n\t * series.events.on(\"hidden\", (ev) => {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * series.events.on(\"hidden\", function(ev) {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"series\": [{\r\n\t *     // ...\r\n\t *     \"events\": {\r\n\t *     \t\"hidden\": function(ev) {\r\n\t *     \t  console.log(\"Series hidden: \" + ev.target.name);\r\n\t *     \t}\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * The above will invoke our custom event handler the first time series we\r\n\t * put event on is hidden.\r\n\t *\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @returns A disposable event listener\r\n\t * @todo what if `listen` is called on the same function twice ?\r\n\t */\r\n\tpublic once<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\r\n\t\tconst x = this._on(true, type, callback, context, shouldClone, (type, event) => {\r\n\t\t\tx.disposer.dispose();\r\n\t\t\tcallback.call(context, event)\r\n\t\t});\r\n\r\n\t\t// TODO maybe this should return a different Disposer ?\r\n\t\treturn x.disposer;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the event listener with specific parameters.\r\n\t *\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t */\r\n\tpublic off<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): void {\r\n\t\tthis._removeExistingListener(false, type, callback, context);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Copies all dispatcher parameters, including listeners, from another event\r\n\t * dispatcher.\r\n\t *\r\n\t * @param source Source event dispatcher\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tif (source === this) {\r\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\r\n\t\t}\r\n\r\n\t\t$array.each(source._listeners, (x) => {\r\n\t\t\t// TODO is this correct ?\r\n\t\t\tif (!x.killed && x.shouldClone) {\r\n\t\t\t\tif (x.type === null) {\r\n\t\t\t\t\tthis.onAll(x.callback, x.context);\r\n\r\n\t\t\t\t} else if (x.once) {\r\n\t\t\t\t\tthis.once(x.type, x.callback, x.context);\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.on(x.type, x.callback, x.context);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * A version of the [[EventDispatcher]] that dispatches events for a specific\r\n * target object.\r\n *\r\n * @important\r\n */\r\nexport class TargetedEventDispatcher<Target, T> extends EventDispatcher<T> {\r\n\r\n\t/**\r\n\t * A target object which is originating events using this dispatcher.\r\n\t */\r\n\tpublic target: Target;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t *\r\n\t * @param target Event dispatcher target\r\n\t */\r\n\tconstructor(target: Target) {\r\n\t\tsuper();\r\n\t\tthis.target = target;\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all dispatcher parameters, including listeners, from another event\r\n\t * dispatcher.\r\n\t *\r\n\t * @param source Source event dispatcher\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tif (source === this) {\r\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\r\n\t\t}\r\n\r\n\t\t$array.each(source._listeners, (x) => {\r\n\t\t\t// TODO very hacky\r\n\t\t\tif (x.context === source.target) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// TODO is this correct ?\r\n\t\t\tif (!x.killed && x.shouldClone) {\r\n\t\t\t\tif (x.type === null) {\r\n\t\t\t\t\tthis.onAll(x.callback, x.context);\r\n\r\n\t\t\t\t} else if (x.once) {\r\n\t\t\t\t\tthis.once(x.type, x.callback, x.context);\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.on(x.type, x.callback, x.context);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n}\r\n","/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\nimport { Ordering } from \"./Order\";\n\n\n/**\n * ============================================================================\n * COMPARING FUNCTIONS\n * ============================================================================\n * @hidden\n */\n\n/**\n * Comparing function used for ordering.\n *\n * @ignore Exclude from docs\n * @todo Use localeCompare\n * @param a  Item 1\n * @param b  Item 2\n * @return Result\n */\nexport function order(a: string, b: string): Ordering {\n\tif (a === b) {\n\t\treturn 0;\n\n\t} else if (a < b) {\n\t\treturn -1;\n\n\t} else {\n\t\treturn 1;\n\t}\n}\n\n\n/**\n * ============================================================================\n * OTHER FUNCTIONS\n * ============================================================================\n * @hidden\n */\n\n/**\n * Repeats a `string` number of times as set in `amount`.\n *\n * @ignore Exclude from docs\n * @todo Make this faster\n * @param string  Source string\n * @param amount  Number of times to repeat string\n * @return New string\n */\nexport function repeat(string: string, amount: number): string {\n\treturn new Array(amount + 1).join(string);\n}\n\n/**\n * Generates a random string `characters` length.\n *\n * @param chars  Number of characters\n * @return Random string\n */\nexport function random(chars: number): string {\n\tlet res = \"\";\n\tlet choice = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\tfor (let i = 0; i < chars; i++) {\n\t\tres += choice.charAt(Math.floor(Math.random() * choice.length));\n\t}\n\treturn res;\n}\n","/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Dictionary } from \"./Dictionary\";\r\nimport * as $type from \"./Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines an interface for cache items.\r\n */\r\ninterface CacheItem<A> {\r\n\r\n\t/**\r\n\t * A timestamp of when the item was created/updated.\r\n\t */\r\n\t\"touched\": number,\r\n\r\n\t/**\r\n\t * TTL (time to live) in milliseconds.\r\n\t */\r\n\t\"ttl\"?: number,\r\n\r\n\t/**\r\n\t * Cached value.\r\n\t */\r\n\t\"value\": A,\r\n\r\n\t/**\r\n\t * Is this item expired?\r\n\t *\r\n\t * @todo a system process that would check chace element TTLs and expire them\r\n\t */\r\n\t\"expired\"?: boolean\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Represents object cache.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Better storage\r\n * @todo TTL logging\r\n * @todo Garbage collector\r\n */\r\nexport class Cache<A> {\r\n\r\n\t/**\r\n\t * Storage for cache items.\r\n\t */\r\n\tprivate _storage = new Dictionary<string, Dictionary<string, CacheItem<A>>>();\r\n\r\n\t/**\r\n\t * Default TTL in milliseconds.\r\n\t */\r\n\tpublic ttl: number = 1000;\r\n\r\n\t/**\r\n\t * Caches or updates cached value, resets TTL.\r\n\t *\r\n\t * If `ttl` is set to zero, item will never expire.\r\n\t *\r\n\t * @param owner  An id of the object that owns this cache\r\n\t * @param key    Index key\r\n\t * @param value  Value\r\n\t * @param ttl    TTL of the cache to live in milliseconds\r\n\t */\r\n\tpublic set(owner: string, key: string, value: A, ttl?: number): void {\r\n\r\n\t\t// Create if storage does not exist for this owner\r\n\t\tlet ownerStorage = this._storage.insertKeyIfEmpty(owner, () => new Dictionary<string, CacheItem<A>>());\r\n\r\n\t\t// Create cache item\r\n\t\tlet item: CacheItem<A> = {\r\n\t\t\t\"touched\": new Date().getTime(),\r\n\t\t\t\"ttl\": $type.isNumber(ttl) ? ttl : this.ttl,\r\n\t\t\t\"value\": value\r\n\t\t};\r\n\r\n\t\t// Set\r\n\t\townerStorage.setKey(key, item);\r\n\t}\r\n\r\n\t/**\r\n\t * Rerturns cached item, respecting TTL.\r\n\t *\r\n\t * @param owner  An id of the object that owns this cache\r\n\t * @param key    Index key\r\n\t * @param value  Value to return if cache not available\r\n\t * @return Value, or `undefined` if not set\r\n\t */\r\n\tpublic get(owner: string, key: string, value: any = undefined): $type.Optional<A> {\r\n\t\t// \t\t || ypeof this._storage[owner][key] === \"undefined\" || this._storage[owner][key].expired === true) {\r\n\t\tif (this._storage.hasKey(owner)) {\r\n\t\t\tlet ownerStorage = <Dictionary<string, CacheItem<A>>>this._storage.getKey(owner);\r\n\r\n\t\t\tif (ownerStorage.hasKey(key)) {\r\n\t\t\t\tlet cacheItem: CacheItem<A> = <CacheItem<A>>ownerStorage.getKey(key);\r\n\t\t\t\tif (cacheItem.ttl && ((cacheItem.touched + cacheItem.ttl) < new Date().getTime())) {\r\n\t\t\t\t\tcacheItem.expired = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (cacheItem.expired) {\r\n\t\t\t\t\townerStorage.removeKey(key);\r\n\t\t\t\t\treturn value;\r\n\t\t\t\t}\r\n\t\t\t\treturn cacheItem.value;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn value;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Clears cache for specific owner or everything.\r\n\t *\r\n\t * @param owner Owner to clear cache for\r\n\t */\r\n\tpublic clear(owner?: string): void {\r\n\t\tif (owner) {\r\n\t\t\tthis._storage.removeKey(owner);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis._storage.clear();\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * ============================================================================\r\n * GLOBAL INSTANCE\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A global instance of cache. Use this instance to cache any values.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport let cache: Cache<any> = new Cache();\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { ITheme } from \"../themes/ITheme\";\r\nimport { EventDispatcher, AMEvent } from \"./utils/EventDispatcher\";\r\nimport { Dictionary } from \"./utils/Dictionary\";\r\nimport { Sprite } from \"./Sprite\";\r\nimport { Container } from \"./Container\";\r\nimport { Component } from \"./Component\";\r\nimport { cache } from \"./utils/Cache\";\r\nimport * as $type from \"./utils/Type\";\r\nimport * as $string from \"./utils/String\";\r\nimport * as $array from \"./utils/Array\";\r\n\r\n\r\n/**\r\n * Define events available for [[Registry]]\r\n */\r\nexport interface IRegistryEvents {\r\n\r\n\t/**\r\n\t * Invoked when update cycle starts. Before invalid elements are re-validated.\r\n\t */\r\n\tenterframe: {};\r\n\r\n\t/**\r\n\t * Invoked when udpate cycle ends. After invalid elements have been\r\n\t * re-validated.\r\n\t */\r\n\texitframe: {};\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Registry is used to store miscellaneous system-wide information, like ids,\r\n * maps, themes, and registered classes.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport class Registry {\r\n\r\n\t/**\r\n\t * Unique ID of the object.\r\n\t */\r\n\tpublic uid: string;\r\n\r\n\t/**\r\n\t * Event dispacther.\r\n\t */\r\n\tpublic events: EventDispatcher<AMEvent<Registry, IRegistryEvents>> = new EventDispatcher();\r\n\r\n\t/**\r\n\t * Holds a universal mapping collection, so that elements and their children\r\n\t * can create and look up all kinds of relations between id and object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected _map: $type.Optional<Dictionary<string, any>>;\r\n\r\n\t/**\r\n\t * All currently applied themes. All new chart instances created will\r\n\t * automatically inherit and retain System's themes.\r\n\t */\r\n\tpublic themes: ITheme[] = [];\r\n\r\n\t/**\r\n\t * List of all loaded available themes.\r\n\t *\r\n\t * Whenever a theme loads, it registers itself in System's `loadedThemes`\r\n\t * collection.\r\n\t */\r\n\tpublic loadedThemes: { [index: string]: ITheme } = {};\r\n\r\n\t/**\r\n\t * An indeternal counter used to generate unique IDs.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected _uidCount: number = 0;\r\n\r\n\t/**\r\n\t * Keeps register of class references so that they can be instnatiated using\r\n\t * string key.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic registeredClasses: { [index: string]: any } = {};\r\n\r\n\t/**\r\n\t * Holds all generated placeholders.\r\n\t */\r\n\tprotected _placeholders: { [index: string]: string } = {};\r\n\r\n\t/**\r\n\t * A list of invalid(ated) [[Sprite]] objects that need to be re-validated\r\n\t * during next cycle.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidSprites: { [index: string]: Array<Sprite> } = {};\r\n\r\n\t/**\r\n\t * Components are added to this list when their data provider changes to\r\n\t * a new one or data is added/removed from their data provider.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidDatas: { [index: string]: Array<Component> } = {};\r\n\r\n\t/**\r\n\t * Components are added to this list when values of their raw data change.\r\n\t * Used when we want a smooth animation from one set of values to another.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidRawDatas: Array<Component> = [];\r\n\r\n\t/**\r\n\t * Components are added to this list when values of their data changes\r\n\t * (but not data provider itself).\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidDataItems: Array<Component> = [];\r\n\r\n\t/**\r\n\t * Components are added to this list when their data range (selection) is\r\n\t * changed, e.g. zoomed.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidDataRange: Array<Component> = [];\r\n\r\n\t/**\r\n\t * A list of [[Sprite]] objects that have invalid(ated) positions, that need\r\n\t * to be recalculated.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidPositions: { [index: string]: Array<Sprite> } = {};\r\n\r\n\t/**\r\n\t * A list of [[Container]] objects with invalid(ated) layouts.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidLayouts: { [index: string]: Array<Container> } = {};\r\n\r\n\t/**\r\n\t * An array holding all active (non-disposed) top level elemens.\r\n\t *\r\n\t * When, for example, a new chart is created, its instance will be added to\r\n\t * this array, and will be removed when the chart is disposed.\r\n\t */\r\n\tpublic baseSprites: Array<Sprite> = [];\r\n\r\n\t/**\r\n\t * An UID-based map of base sprites (top-level charts).\r\n\t */\r\n\tpublic baseSpritesByUid: { [index: string]: Sprite } = {};\r\n\r\n\t/**\r\n\t * Queued charts (waiting for their turn) to initialize.\r\n\t * \r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/performance/#Daisy_chaining_multiple_charts} for more information\r\n\t */\r\n\tpublic queue: Array<Sprite> = [];\r\n\r\n\t/**\r\n\t * An array of deferred charts that haven't been created yet.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/performance/#Deferred_daisy_chained_instantiation} for more information\r\n\t * @since 4.10.0\r\n\t */\r\n\tpublic deferred: Array<{\r\n\t\tcallback: (...args: Array<any>) => Sprite,\r\n\t\tscope?: any,\r\n\t\targs?: Array<any>,\r\n\t\tresolve: any\r\n\t}> = [];\r\n\r\n\tconstructor() {\r\n\t\tthis.uid = this.getUniqueId();\r\n\r\n\t\tthis.invalidSprites.noBase = [];\r\n\t\tthis.invalidDatas.noBase = [];\r\n\t\tthis.invalidLayouts.noBase = [];\r\n\t\tthis.invalidPositions.noBase = [];\r\n\r\n\t\t// This is needed for Angular Universal SSR\r\n\t\tif (typeof addEventListener !== \"undefined\") {\r\n\t\t\t// This is needed to prevent charts from being cut off when printing\r\n\t\t\taddEventListener(\"beforeprint\", () => {\r\n\t\t\t\t$array.each(this.baseSprites, (sprite) => {\r\n\t\t\t\t\tconst svg = sprite.paper.svg;\r\n\t\t\t\t\tsvg.setAttribute(\"viewBox\", \"0 0 \" + svg.clientWidth + \" \" + svg.clientHeight);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\r\n\t\t\taddEventListener(\"afterprint\", () => {\r\n\t\t\t\t$array.each(this.baseSprites, (sprite) => {\r\n\t\t\t\t\tconst svg = sprite.paper.svg;\r\n\t\t\t\t\tsvg.removeAttribute(\"viewBox\");\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Generates a unique chart system-wide ID.\r\n\t *\r\n\t * @return Generated ID\r\n\t */\r\n\tpublic getUniqueId(): string {\r\n\t\tlet uid = this._uidCount;\r\n\t\tthis._uidCount += 1;\r\n\t\treturn \"id-\" + uid;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a universal collection for mapping ids with objects.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Map collection\r\n\t */\r\n\tpublic get map(): Dictionary<string, any> {\r\n\t\tif (!this._map) {\r\n\t\t\tthis._map = new Dictionary<string, any>();\r\n\t\t}\r\n\t\treturn this._map;\r\n\t}\r\n\r\n\t/**\r\n\t * Caches value in object's cache.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param key    Key\r\n\t * @param value  Value\r\n\t * @param ttl    TTL in seconds\r\n\t */\r\n\tpublic setCache(key: string, value: any, ttl?: number): void {\r\n\t\tcache.set(this.uid, key, value, ttl);\r\n\t}\r\n\r\n\t/**\r\n\t * Retrieves cached value.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param key    Key\r\n\t * @param value  Value to return if cache is not available\r\n\t * @return Value\r\n\t */\r\n\tpublic getCache(key: string, value: any = undefined): any {\r\n\t\treturn cache.get(this.uid, key, value);\r\n\t}\r\n\r\n\t/**\r\n\t * Dispatches an event using own event dispatcher. Will automatically\r\n\t * populate event data object with event type and target (this element).\r\n\t * It also checks if there are any handlers registered for this sepecific\r\n\t * event.\r\n\t *\r\n\t * @param eventType Event type (name)\r\n\t * @param data      Data to pass into event handler(s)\r\n\t */\r\n\tpublic dispatch<Key extends keyof IRegistryEvents>(eventType: Key, data?: any): void {\r\n\t\t// @todo Implement proper type check\r\n\t\tif (this.events.isEnabled(eventType)) {\r\n\t\t\tif (data) {\r\n\t\t\t\tdata.type = eventType;\r\n\t\t\t\tdata.target = data.target || this;\r\n\t\t\t\t(<any>this.events).dispatch(eventType, {\r\n\t\t\t\t\ttype: eventType,\r\n\t\t\t\t\ttarget: this\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t(<any>this.events).dispatch(eventType, {\r\n\t\t\t\t\ttype: eventType,\r\n\t\t\t\t\ttarget: this\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Works like `dispatch`, except event is triggered immediately, without\r\n\t * waiting for the next frame cycle.\r\n\t *\r\n\t * @param eventType Event type (name)\r\n\t * @param data      Data to pass into event handler(s)\r\n\t */\r\n\tpublic dispatchImmediately<Key extends keyof IRegistryEvents>(eventType: Key, data?: any): void {\r\n\t\t// @todo Implement proper type check\r\n\t\tif (this.events.isEnabled(eventType)) {\r\n\t\t\tif (data) {\r\n\t\t\t\tdata.type = eventType;\r\n\t\t\t\tdata.target = data.target || this;\r\n\t\t\t\t(<any>this.events).dispatchImmediately(eventType, data);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t(<any>this.events).dispatchImmediately(eventType, {\r\n\t\t\t\t\ttype: eventType,\r\n\t\t\t\t\ttarget: this\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a unique placeholder suitable for the key.\r\n\t *\r\n\t * @param key  Key\r\n\t * @return Random string to be used as placeholder\r\n\t */\r\n\tpublic getPlaceholder(key: string): string {\r\n\t\tif ($type.hasValue(this._placeholders[key])) {\r\n\t\t\treturn this._placeholders[key];\r\n\t\t}\r\n\t\tthis._placeholders[key] = \"__amcharts_\" + key + \"_\" + $string.random(8) + \"__\";\r\n\t\treturn this._placeholders[key];\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic addToInvalidComponents(component: Component) {\r\n\t\tif (component.baseId) {\r\n\t\t\t$array.move(this.invalidDatas[component.baseId], component);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$array.move(this.invalidDatas[\"noBase\"], component);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic removeFromInvalidComponents(component: Component) {\r\n\t\tif (component.baseId) {\r\n\t\t\t$array.remove(this.invalidDatas[component.baseId], component);\r\n\t\t}\r\n\r\n\t\t$array.remove(this.invalidDatas[\"noBase\"], component);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic addToInvalidSprites(sprite: Sprite) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.add(this.invalidSprites[sprite.baseId], sprite);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$array.add(this.invalidSprites[\"noBase\"], sprite);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic removeFromInvalidSprites(sprite: Sprite) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.remove(this.invalidSprites[sprite.baseId], sprite);\r\n\t\t}\r\n\r\n\t\t$array.remove(this.invalidSprites[\"noBase\"], sprite);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic addToInvalidPositions(sprite: Sprite) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.add(this.invalidPositions[sprite.baseId], sprite);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$array.add(this.invalidPositions[\"noBase\"], sprite);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic removeFromInvalidPositions(sprite: Sprite) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.remove(this.invalidPositions[sprite.baseId], sprite);\r\n\t\t}\r\n\r\n\t\t$array.remove(this.invalidPositions[\"noBase\"], sprite);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic addToInvalidLayouts(sprite: Container) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.add(this.invalidLayouts[sprite.baseId], sprite);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$array.add(this.invalidLayouts[\"noBase\"], sprite);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic removeFromInvalidLayouts(sprite: Container) {\r\n\t\tif (sprite.baseId) {\r\n\t\t\t$array.remove(this.invalidLayouts[sprite.baseId], sprite);\r\n\t\t}\r\n\r\n\t\t$array.remove(this.invalidLayouts[\"noBase\"], sprite);\r\n\t}\r\n}\r\n\r\n/**\r\n * A singleton global instance of [[Registry]].\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport let registry = new Registry();\r\n\r\n\r\n/**\r\n * Returns `true` if object is an instance of the class. It's the same as `instanceof` except it doesn't need to import the class.\r\n *\r\n * @param object Object\r\n * @param name Class name\r\n * @return Is instance of class\r\n */\r\nexport function is<A>(object: any, name: string): object is A {\r\n\tconst x = registry.registeredClasses[name];\r\n\treturn x != null && object instanceof x;\r\n}\r\n","/**\r\n * A collection of utility functions for various type checks and conversion\r\n * @todo Review unused functions for removal\r\n * @hidden\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { percent, Percent, isPercent } from \"./Percent\";\r\n\r\n\r\n/**\r\n * @todo Description\r\n * @ignore Exclude from docs\r\n */\r\nexport type Public<T> = {[P in keyof T]: T[P]};\r\n\r\n\r\n/**\r\n * `Keyof<T>` is the same as `keyof T` except it only accepts string keys, not numbers or symbols.\r\n */\r\nexport type Keyof<T> = Extract<keyof T, string>;\r\n\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * TYPE CHECK\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Returns `true` if value is not a number (NaN).\r\n *\r\n * @param value Input value\r\n * @return Is NaN?\r\n * @deprecated Is not used anywhere. JS built-in isNaN is used everywhere. Maybe we don't need this, or if we do, then we should use it everywhere\r\n */\r\nexport function isNaN(value: number): boolean {\r\n\treturn Number(value) !== value;\r\n}\r\n\r\n/**\r\n * Represents a type for all available JavaScript variable types.\r\n */\r\nexport type Type\r\n\t= \"[object Object]\"\r\n\t| \"[object Array]\"\r\n\t| \"[object String]\"\r\n\t| \"[object Number]\"\r\n\t| \"[object Boolean]\"\r\n\t| \"[object Date]\";\r\n\r\n/**\r\n * Returns a type of the value.\r\n *\r\n * @param value  Input value\r\n * @return Type of the value\r\n */\r\nexport function getType<A>(value: A): Type {\r\n\treturn ({}).toString.call(value) as Type;\r\n}\r\n\r\n/**\r\n * Returns a default value if the passed in value is empty.\r\n *\r\n * @param value     Input value\r\n * @param optional  Default value\r\n * @return Value or default value whichever is available\r\n * @deprecated Not used anywhere\r\n */\r\nexport function getDefault<A>(value: null | undefined | A, optional: A): A {\r\n\treturn value || optional;\r\n}\r\n\r\n/**\r\n * Checks if the passed in value is a string.\r\n *\r\n * @param value  Value\r\n * @return Is string?\r\n * @throws {Error}\r\n * @deprecated Not used anywhere\r\n */\r\nexport function checkString(value: any): value is string {\r\n\tif (typeof value === \"string\") {\r\n\t\treturn true;\r\n\t} else {\r\n\t\tthrow new Error(\"Expected a string but got \" + getType(value));\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks if the passed in value is a boolean.\r\n *\r\n * @param value  Value\r\n * @return Is boolean?\r\n * @throws {Error}\r\n * @deprecated Not used anywhere\r\n */\r\nexport function checkBoolean(value: any): value is boolean {\r\n\tif (typeof value === \"boolean\") {\r\n\t\treturn true;\r\n\t} else {\r\n\t\tthrow new Error(\"Expected a boolean but got \" + getType(value));\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks if the passed in value is a number.\r\n *\r\n * @param value  Value\r\n * @return Is number?\r\n * @throws {Error}\r\n */\r\nexport function checkNumber(value: any): value is number {\r\n\tif (typeof value === \"number\") {\r\n\t\tif (isNaN(value)) {\r\n\t\t\tthrow new Error(\"Expected a number but got NaN\");\r\n\t\t}\r\n\t} else {\r\n\t\tthrow new Error(\"Expected a number but got \" + getType(value));\r\n\t}\r\n\treturn true;\r\n}\r\n\r\n/**\r\n * Checks if the passed in value is an object.\r\n *\r\n * @param value  Value\r\n * @return Is object?\r\n * @throws {Error}\r\n * @todo Is the input type correct?\r\n * @deprecated Not used anywhere\r\n */\r\nexport function checkObject(value: {}): value is {} {\r\n\tconst t = getType(value);\r\n\r\n\tif (t === \"[object Object]\") {\r\n\t\treturn true;\r\n\r\n\t} else {\r\n\t\tthrow new Error(\"Expected an object but got \" + t);\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks if the passed in value is an array.\r\n *\r\n * @param value  Value\r\n * @return Is array?\r\n * @throws {Error}\r\n * @deprecated Not used anywhere\r\n */\r\nexport function checkArray<A>(value: Array<A>): value is Array<A> {\r\n\tif (Array.isArray(value)) {\r\n\t\treturn true;\r\n\r\n\t} else {\r\n\t\tthrow new Error(\"Expected an array but got \" + getType(value));\r\n\t}\r\n}\r\n\r\n/**\r\n * Checks if the passed in value is a Date object.\r\n *\r\n * @param value  Value\r\n * @return Is Date object?\r\n * @throws {Error}\r\n * @deprecated Not used anywhere\r\n */\r\nexport function checkDate(value: Date): value is Date {\r\n\tconst t = getType(value);\r\n\r\n\tif (t === \"[object Date]\") {\r\n\t\treturn true;\r\n\r\n\t} else {\r\n\t\tthrow new Error(\"Expected a date but got \" + t);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * TYPE CASTING\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Casts string or a number into string.\r\n *\r\n * @param value  Input\r\n * @return String value\r\n * @deprecated Not used anywhere\r\n */\r\nexport function castString(value: string | number): string {\r\n\tif (typeof value === \"string\") {\r\n\t\treturn value;\r\n\r\n\t} else if (typeof value === \"number\") {\r\n\t\treturn \"\" + value;\r\n\r\n\t} else {\r\n\t\tthrow new Error(\"Expected a string or number but got \" + getType(value));\r\n\t}\r\n}\r\n\r\n/**\r\n * Casts string or a number into a number.\r\n *\r\n * @param value   Input value\r\n * @return Number  value\r\n * @throws {Error}\r\n */\r\nexport function castNumber(value: string | number | Date): number {\r\n\tif (typeof value === \"string\") {\r\n\t\tconst number = +value;\r\n\r\n\t\tif (isNaN(number)) {\r\n\t\t\tthrow new Error(\"Cannot cast string \" + JSON.stringify(value) + \" to a number\");\r\n\r\n\t\t} else {\r\n\t\t\treturn number;\r\n\t\t}\r\n\r\n\t} else if (typeof value === \"number\") {\r\n\t\tif (isNaN(value)) {\r\n\t\t\tthrow new Error(\"Expected a number but got NaN\");\r\n\r\n\t\t} else {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t} else {\r\n\t\tconst t = getType(value);\r\n\r\n\t\tif (t === \"[object Date]\") {\r\n\t\t\treturn value.getTime();\r\n\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Expected a string, number, or date but got \" + t);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Casts number, string or Date into a Date object.\r\n *\r\n * @param value  Input value\r\n * @return Date object\r\n * @deprecated Not used anywhere\r\n * @throws {Error}\r\n * @hidden\r\n * @deprecated\r\n */\r\n/*export function castDate(value: string | number | Date, formatter?: DateFormatter): Date {\r\n\tif (typeof value === \"string\") {\r\n\t\tif (formatter) {\r\n\t\t\treturn formatter.parse(value);\r\n\t\t}\r\n\t\treturn new Date(value);\r\n\r\n\t} else if (typeof value === \"number\") {\r\n\t\treturn new Date(value);\r\n\r\n\t} else {\r\n\t\tconst t = getType(value);\r\n\r\n\t\tif (t === \"[object Date]\") {\r\n\t\t\treturn value;\r\n\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Expected a string, number, or date but got \" + t);\r\n\t\t}\r\n\t}\r\n}*/\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * QUICK CONVERSION\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n\r\n/**\r\n * Converts any value into `boolean`.\r\n *\r\n * @param value  Source value\r\n * @return `true` or `false`\r\n */\r\nexport function toBoolean(value: any): boolean {\r\n\treturn value ? true : false;\r\n}\r\n\r\n/**\r\n * Converts any value into a `number`.\r\n *\r\n * @param value  Source value\r\n * @return Number representation of value\r\n */\r\nexport function toNumber(value: any): number {\r\n\tif (hasValue(value) && !isNumber(value)) {\r\n\t\tlet converted = Number(value);\r\n\t\tif (isNaN(converted) && isString(value) && value != \"\") {\r\n\t\t\treturn toNumber(value.replace(/[^0-9.\\-]+/g, ''));\r\n\t\t}\r\n\t\treturn converted;\r\n\t}\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Converts any value into a string (text).\r\n *\r\n * @param value  Source value\r\n * @return String representation of the input\r\n */\r\nexport function toText(value: any): string {\r\n\tif (hasValue(value) && !isString(value)) {\r\n\t\tif (isNumber(value)) {\r\n\t\t\treturn castString(value);\r\n\t\t}\r\n\t\telse if (isObject(value)) {\r\n\t\t\treturn value.toString();\r\n\t\t}\r\n\t}\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Converts any value to a number or [[Percent]].\r\n *\r\n * If the parameter is a string and contains \"%\", it will\r\n * convert it into a [[Percent]].\r\n *\r\n * Otherwise, it will convert into a number.\r\n *\r\n * @param value  Number or percent\r\n * @return Percent object\r\n */\r\nexport function toNumberOrPercent(value: any): number | Percent {\r\n\tif (!hasValue(value) || isNumber(value) || isPercent(value)) {\r\n\t\treturn value;\r\n\t}\r\n\tif (isString(value) && value.indexOf(\"%\") != -1) {\r\n\t\treturn percent(toNumber(value));\r\n\t}\r\n\treturn toNumber(value);\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * VALUE PRESENCE CHECK\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines an optional value that can be of any type or `undefined`.\r\n */\r\nexport type Optional<A> = A | undefined;\r\n\r\n/**\r\n * Checks if a variable has a value.\r\n *\r\n * @param a  Input value\r\n * @returns                        Has value?\r\n */\r\nexport function hasValue<A>(a: Optional<A> | null): a is A {\r\n\treturn a != null;\r\n}\r\n\r\n/**\r\n * Returns a value or throws an {Error} exception if the variable has not\r\n * value.\r\n *\r\n * @param a  Input value\r\n * @returns                        Value\r\n */\r\nexport function getValue<A>(a: Optional<A> | null): A {\r\n\tif (hasValue(a)) {\r\n\t\treturn a;\r\n\r\n\t} else {\r\n\t\tthrow new Error(\"Value doesn't exist\");\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns a value, or returns the default value if it doesn't have a value.\r\n *\r\n * @param a  Input value\r\n * @returns                        Value\r\n */\r\nexport function getValueDefault<A>(a: Optional<A> | null, defaultValue: A): A {\r\n\tif (hasValue(a)) {\r\n\t\treturn a;\r\n\r\n\t} else {\r\n\t\treturn defaultValue;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * TYPE CHECK\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Checks if parameter is `Date`.\r\n *\r\n * @param value  Input value\r\n * @return Is Date?\r\n */\r\nexport function isDate(value: any): value is Date {\r\n\treturn getType(value) === \"[object Date]\";\r\n}\r\n\r\n/**\r\n * Checks if parameter is `string`.\r\n *\r\n * @param value  Input value\r\n * @return Is string?\r\n */\r\nexport function isString(value: any): value is string {\r\n\treturn typeof value === \"string\";\r\n}\r\n\r\n/**\r\n * Checks if parameter is `number`.\r\n *\r\n * @param value  Input value\r\n * @return Is number?\r\n */\r\nexport function isNumber(value: any): value is number {\r\n\treturn typeof value === \"number\" && Number(value) == value;\r\n}\r\n\r\n/**\r\n * Checks if parameter is `object`.\r\n *\r\n * @param value  Input value\r\n * @return Is object?\r\n */\r\nexport function isObject(value: any): value is object {\r\n\treturn typeof value === \"object\" && value != null;\r\n}\r\n\r\n/**\r\n * Checks if parameter is `Array`.\r\n *\r\n * @param value  Input value\r\n * @return Is Array?\r\n */\r\nexport function isArray(value: any): value is Array<any> {\r\n\treturn Array.isArray(value);\r\n}\r\n","/**\r\n * A collection of Math-related functions\r\n *\r\n * @todo Comment trigonometric functions?\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { IPoint } from \"../defs/IPoint\";\r\nimport { IRectangle } from \"../defs/IRectangle\";\r\nimport { IRange } from \"../defs/IRange\";\r\nimport * as $type from \"./Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * CONSTANTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nexport const PI = Math.PI;\r\nexport const HALFPI = PI / 2;\r\nexport const RADIANS = PI / 180;\r\nexport const DEGREES = 180 / PI;\r\n\r\n/**\r\n * Converts any value and fits it into a specific value range.\r\n *\r\n * @param value  Source value\r\n * @param min    Minimum allowable value\r\n * @param max    Maximum allowable value\r\n * @return Number\r\n */\r\nexport function toNumberRange(value: any, min: number, max: number): number {\r\n\tif ($type.hasValue(value)) {\r\n\t\tvalue = $type.toNumber(value);\r\n\t\treturn fitToRange(value, min, max);\r\n\t}\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Rounds the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\r\n * @return Rounded value\r\n */\r\nexport function round(value: number, precision?: number, floor?: boolean): number {\r\n\tif (!$type.isNumber(precision) || precision <= 0) {\r\n\r\n\t\tlet rounded = Math.round(value);\r\n\t\tif (floor) {\r\n\t\t\tif (rounded - value == 0.5) {\r\n\t\t\t\trounded--;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn rounded;\r\n\t}\r\n\telse {\r\n\t\tlet d: number = Math.pow(10, precision);\r\n\t\treturn Math.round(value * d) / d;\r\n\t}\r\n}\r\n\r\n/**\r\n * Ceils the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @return Rounded value\r\n */\r\nexport function ceil(value: number, precision?: number): number {\r\n\tif (!$type.isNumber(precision) || precision <= 0) {\r\n\t\treturn Math.ceil(value);\r\n\t}\r\n\telse {\r\n\t\tlet d: number = Math.pow(10, precision);\r\n\t\treturn Math.ceil(value * d) / d;\r\n\t}\r\n}\r\n\r\n/**\r\n * Stretches `t` so that it will always be between `from` and `to`.\r\n *\r\n * @param t     Number from 0 to 1\r\n * @param from  Lowest possible value\r\n * @param to    Highest possible value\r\n * @return Adjusted value\r\n */\r\nexport function stretch(t: number, from: number, to: number): number {\r\n\treturn (t * (to - from)) + from;\r\n}\r\n\r\n\r\n/**\r\n * Adjust numeric value so it fits to specific value range.\r\n *\r\n * @param value     Value\r\n * @param minValue  Lowest possible value\r\n * @param maxValue  Highest possible value\r\n * @return Adjusted value\r\n */\r\nexport function fitToRange(value: number, minValue: $type.Optional<number>, maxValue: $type.Optional<number>): number {\r\n\tif ($type.isNumber(minValue)) {\r\n\t\tif ($type.isNumber(maxValue) && maxValue < minValue) {\r\n\t\t\tlet temp = maxValue;\r\n\t\t\tmaxValue = minValue;\r\n\t\t\tminValue = temp;\r\n\t\t}\r\n\r\n\t\tif (value < minValue) {\r\n\t\t\tvalue = minValue;\r\n\t\t}\r\n\t}\r\n\r\n\tif ($type.isNumber(maxValue)) {\r\n\t\tif (value > maxValue) {\r\n\t\t\tvalue = maxValue;\r\n\t\t}\r\n\t}\r\n\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Returns sine of a number.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\r\nexport function sin(value: number): number {\r\n\treturn round(Math.sin(RADIANS * value), 10);\r\n}\r\n\r\n/**\r\n * Returns tan of a number.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\r\nexport function tan(value: number): number {\r\n\treturn round(Math.tan(RADIANS * value), 10);\r\n}\r\n\r\n/**\r\n * Returns cosine of a number.\r\n *\r\n * @param value  Value\r\n * @return Cosine\r\n */\r\nexport function cos(value: number): number {\r\n\treturn round(Math.cos(RADIANS * value), 10);\r\n}\r\n\r\n/**\r\n * Returns biggest value out of passed in numeric values.\r\n *\r\n * @param left   Numeric value\r\n * @param right  Numeric value\r\n * @return Biggest value\r\n */\r\nexport function max(left: number, right: number): number;\r\nexport function max(left: number, right: $type.Optional<number>): number;\r\nexport function max(left: $type.Optional<number>, right: number): number;\r\nexport function max(left: $type.Optional<number>, right: $type.Optional<number>): $type.Optional<number>;\r\nexport function max(left: any, right: any): any {\r\n\tif ($type.isNumber(left)) {\r\n\t\tif ($type.isNumber(right)) {\r\n\t\t\tif (right > left) {\r\n\t\t\t\treturn right;\r\n\r\n\t\t\t} else {\r\n\t\t\t\treturn left;\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\treturn left;\r\n\t\t}\r\n\r\n\t} else if ($type.isNumber(right)) {\r\n\t\treturn right;\r\n\r\n\t} else {\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns smallest value out of passed in numeric values.\r\n *\r\n * @param left   Numeric value\r\n * @param right  Numeric value\r\n * @return Smallest value\r\n */\r\nexport function min(left: number, right: number): number;\r\nexport function min(left: number, right: $type.Optional<number>): number;\r\nexport function min(left: $type.Optional<number>, right: number): number;\r\nexport function min(left: $type.Optional<number>, right: $type.Optional<number>): $type.Optional<number>;\r\nexport function min(left: any, right: any): any {\r\n\tif ($type.isNumber(left)) {\r\n\t\tif ($type.isNumber(right)) {\r\n\t\t\tif (right < left) {\r\n\t\t\t\treturn right;\r\n\r\n\t\t\t} else {\r\n\t\t\t\treturn left;\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\treturn left;\r\n\t\t}\r\n\r\n\t} else if ($type.isNumber(right)) {\r\n\t\treturn right;\r\n\r\n\t} else {\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns the closest value from the array of values to the reference value.\r\n *\r\n * @param values  Array of values\r\n * @param value   Reference value\r\n * @return Closes value from the array\r\n */\r\nexport function closest(values: number[], referenceValue: number): number {\r\n\treturn values.reduce(function(prev, curr) {\r\n\t\treturn (Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev);\r\n\t});\r\n}\r\n\r\n/**\r\n * Checks whether two ranges of values intersect.\r\n *\r\n * @param range1  Range 1\r\n * @param range2  Range 2\r\n * @return Any intersecting numbers?\r\n */\r\nexport function intersect(range1: IRange, range2: IRange): boolean {\r\n\tlet start1: number = $type.getValue(range1.start);\r\n\tlet start2: number = $type.getValue(range2.start);\r\n\tlet end1: number = $type.getValue(range1.end);\r\n\tlet end2: number = $type.getValue(range2.end);\r\n\r\n\treturn Math.max(start1, start2) <= Math.min(end1, end2);\r\n}\r\n\r\n/**\r\n * Inverts the range of values.\r\n *\r\n * @param range  Range\r\n */\r\nexport function invertRange(range: IRange) {\r\n\tlet start: number = $type.getValue(range.start);\r\n\tlet end: number = $type.getValue(range.end);\r\n\treturn { start: 1 - end, end: 1 - start };\r\n}\r\n\r\n/**\r\n * Returns an intersection range between two ranges of values.\r\n *\r\n * @param range1  Range 1\r\n * @param range2  Range 2\r\n * @return Intersecting value range\r\n */\r\nexport function intersection(range1: IRange, range2: IRange): $type.Optional<IRange> {\r\n\tlet start1: number = $type.getValue(range1.start);\r\n\tlet start2: number = $type.getValue(range2.start);\r\n\tlet end1: number = $type.getValue(range1.end);\r\n\tlet end2: number = $type.getValue(range2.end);\r\n\tlet startMax: number = Math.max(start1, start2);\r\n\tlet endMin: number = Math.min(end1, end2);\r\n\r\n\tif (endMin < startMax) {\r\n\t\treturn undefined;\r\n\t}\r\n\telse {\r\n\t\treturn { start: startMax, end: endMin };\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns pixel \"distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\r\nexport function getDistance(point1: IPoint, point2?: IPoint): number {\r\n\tif (!point1) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (!point2) {\r\n\t\tpoint2 = { x: 0, y: 0 };\r\n\t}\r\n\treturn Math.sqrt(Math.pow(Math.abs(point1.x - point2.x), 2) + Math.pow(Math.abs(point1.y - point2.y), 2));\r\n}\r\n\r\n/**\r\n * Returns pixel \"horizontal distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\r\nexport function getHorizontalDistance(point1: IPoint, point2?: IPoint): number {\r\n\tif (!point1) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (!point2) {\r\n\t\tpoint2 = { x: 0, y: 0 };\r\n\t}\r\n\treturn Math.abs(point1.x - point2.x);\r\n}\r\n\r\n/**\r\n * Returns pixel \"vertical distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\r\nexport function getVerticalDistance(point1: IPoint, point2?: IPoint): number {\r\n\tif (!point1) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (!point2) {\r\n\t\tpoint2 = { x: 0, y: 0 };\r\n\t}\r\n\treturn Math.abs(point1.y - point2.y);\r\n}\r\n\r\n/**\r\n * Returns approximate pixel \"distance\" between two points of cubic curve\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @param controlPointA  Control Point 1\r\n * @param controlPointB  Control Point 2\r\n * @param stepCount  number of steps (the more, the more accurate result)\r\n * @return Distance in relative pixels\r\n */\r\nexport function getCubicCurveDistance(point1: IPoint, point2: IPoint, controlPointA: IPoint, controlPointB: IPoint, stepCount:number): number {\r\n\tif (!point1) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (!point2) {\r\n\t\tpoint2 = { x: 0, y: 0 };\r\n\t}\r\n\r\n\tlet distance = 0;\r\n\tlet prevPoint: IPoint = point1;\r\n\tif (stepCount > 0) {\r\n\t\tfor (let s = 0; s <= stepCount; s++) {\r\n\t\t\tlet point = getPointOnCubicCurve(point1, point2, controlPointA, controlPointB, s / stepCount);\r\n\t\t\tdistance += getDistance(prevPoint, point);\r\n\t\t\tprevPoint = point;\r\n\t\t}\r\n\t}\r\n\treturn distance;\r\n}\r\n\r\n/**\r\n * Returns scale based on original and end position of the two points.\r\n *\r\n * @param point1       Current position of point 1\r\n * @param startPoint1  Start position of point 1\r\n * @param point2       Current position of point 1\r\n * @param startPoint2  Start position of point 2\r\n * @return Scale        Calculated scale\r\n */\r\nexport function getScale(point1: IPoint, startPoint1: IPoint, point2: IPoint, startPoint2: IPoint): number {\r\n\tlet initialDistance: number = getDistance(startPoint1, startPoint2);\r\n\tlet currentDistance: number = getDistance(point1, point2);\r\n\r\n\treturn Math.abs(currentDistance / initialDistance);\r\n}\r\n\r\n/**\r\n * Returns an exact mid point between two points.\r\n *\r\n * @param point1     Position of point 1\r\n * @param point2     Position of point 2\r\n * @return Mid point  Position of mid-point\r\n */\r\nexport function getMidPoint(point1: IPoint, point2: IPoint, position?: number): IPoint {\r\n\tif (!$type.isNumber(position)) {\r\n\t\tposition = 0.5;\r\n\t}\r\n\r\n\treturn {\r\n\t\t\"x\": (point1.x + (point2.x - point1.x) * position),\r\n\t\t\"y\": (point1.y + (point2.y - point1.y) * position)\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns difference in angles between starting and ending position of two\r\n * vectors.\r\n *\r\n * @param point1       Current position of point 1\r\n * @param startPoint1  Start position of point 1\r\n * @param point2       Current position of point 1\r\n * @param startPoint2  Start position of point 2\r\n * @return Angle difference in degrees\r\n */\r\nexport function getRotation(point1: IPoint, startPoint1: IPoint, point2: IPoint, startPoint2: IPoint): number {\r\n\r\n\t// Get start and end angles\r\n\tlet startAngle: number = getAngle(startPoint1, startPoint2);\r\n\tlet angle: number = getAngle(point1, point2);\r\n\r\n\t// Calculate angle\r\n\tlet diff: number = startAngle - angle;\r\n\tif (diff < 0) {\r\n\t\tdiff += 360;\r\n\t}\r\n\r\n\treturn diff;\r\n}\r\n\r\n/**\r\n * Calculates angle of the vector based on two or one point.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Angle in degrees\r\n */\r\nexport function getAngle(point1: IPoint, point2?: IPoint): number {\r\n\tif (!point2) {\r\n\t\tpoint2 = { x: point1.x * 2, y: point1.y * 2 };\r\n\t}\r\n\tlet diffX: number = point2.x - point1.x;\r\n\tlet diffY: number = point2.y - point1.y;\r\n\tlet angle: number = Math.atan2(diffY, diffX) * DEGREES;\r\n\tif (angle < 0) {\r\n\t\tangle += 360;\r\n\t}\r\n\treturn normalizeAngle(angle);\r\n}\r\n\r\n/**\r\n * Returns the shift in coordinates of the center when item is rotated, moved\r\n * and scaled at the same time.\r\n *\r\n * @param center       Current center\r\n * @param point1       Frst reference point\r\n * @param startPoint1  Original position of the first reference point\r\n * @param point2       Second reference point\r\n * @param startPoint2  Original position of the first reference point\r\n * @return Shift in center point coordinates\r\n */\r\nexport function getCenterShift(center: IPoint, point1: IPoint, startPoint1: IPoint, point2: IPoint, startPoint2: IPoint): IPoint {\r\n\r\n\t// Get angle\r\n\tlet angle: number = getRotation(point1, startPoint1, point2, startPoint2) - 90;\r\n\tif (angle < 0) {\r\n\t\tangle += 360;\r\n\t}\r\n\r\n\t// Get distance between new position\r\n\tlet distance: number = getDistance(point1, point2);\r\n\r\n\t// Calculate new X\r\n\tlet x: number = Math.cos(angle) / distance + point1.x;\r\n\tlet y: number = Math.cos(angle) / distance + point1.y;\r\n\r\n\tlet shift: IPoint = {\r\n\t\t\"x\": x - center.x,\r\n\t\t\"y\": y - center.y\r\n\t}\r\n\treturn shift;\r\n}\r\n\r\n/**\r\n * Converts an array of points into a bounding box rectangle.\r\n *\r\n * Array can contain any number of points.\r\n *\r\n * @param points  Points\r\n * @return Bounding box rectangle\r\n */\r\nexport function getBBox(points: IPoint[]): $type.Optional<IRectangle> {\r\n\tif (points) {\r\n\t\tlet length = points.length;\r\n\r\n\t\tif (length !== 0) {\r\n\t\t\tlet left!: number;\r\n\t\t\tlet right!: number;\r\n\t\t\tlet top!: number;\r\n\t\t\tlet bottom!: number;\r\n\r\n\t\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\t\tlet point: IPoint = points[i];\r\n\r\n\t\t\t\tif (!$type.isNumber(right) || (point.x > right)) {\r\n\t\t\t\t\tright = point.x;\r\n\t\t\t\t}\r\n\t\t\t\tif (!$type.isNumber(left) || (point.x < left)) {\r\n\t\t\t\t\tleft = point.x;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!$type.isNumber(top) || (point.y < top)) {\r\n\t\t\t\t\ttop = point.y;\r\n\t\t\t\t}\r\n\t\t\t\tif (!$type.isNumber(bottom) || (point.y > bottom)) {\r\n\t\t\t\t\tbottom = point.y;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn { x: left, y: top, width: right - left, height: bottom - top };\r\n\t\t}\r\n\t}\r\n\r\n\treturn { x: 0, y: 0, width: 0, height: 0 };\r\n}\r\n\r\n/**\r\n * Returns a [[IRectangle]] object representing a common rectangle that fits\r\n * all passed in rectangles in it.\r\n *\r\n * @param rectangles  An array of rectangles\r\n * @return Common rectangle\r\n */\r\nexport function getCommonRectangle(rectangles: IRectangle[]): $type.Optional<IRectangle> {\r\n\tlet length = rectangles.length;\r\n\r\n\tif (length !== 0) {\r\n\t\tlet minX!: number;\r\n\t\tlet minY!: number;\r\n\t\tlet maxX!: number;\r\n\t\tlet maxY!: number;\r\n\r\n\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\tlet rectangle = rectangles[i];\r\n\t\t\tminX = min(rectangle.x, minX);\r\n\t\t\tminY = min(rectangle.y, minY);\r\n\t\t\tmaxX = max(rectangle.x + rectangle.width, maxX);\r\n\t\t\tmaxY = max(rectangle.y + rectangle.height, maxY);\r\n\t\t}\r\n\r\n\t\treturn { x: minX, y: minY, width: maxX - minX, height: maxY - minY };\r\n\t}\r\n}\r\n\r\n/**\r\n * [getPointOnQuadraticCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA        [description]\r\n * @param pointB        [description]\r\n * @param controlPoint  [description]\r\n * @param position      [description]\r\n * @return [description]\r\n */\r\nexport function getPointOnQuadraticCurve(pointA: IPoint, pointB: IPoint, controlPoint: IPoint, position: number): IPoint {\r\n\tlet x: number = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\r\n\tlet y: number = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\r\n\treturn { x: x, y: y };\r\n}\r\n\r\n/**\r\n * [getPointOnCubicCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA         [description]\r\n * @param pointB         [description]\r\n * @param controlPointA  [description]\r\n * @param controlPointB  [description]\r\n * @param position       [description]\r\n * @return [description]\r\n */\r\nexport function getPointOnCubicCurve(pointA: IPoint, pointB: IPoint, controlPointA: IPoint, controlPointB: IPoint, position: number): IPoint {\r\n\tlet point: IPoint = { x: 0, y: 0 };\r\n\tlet mt1: number = 1 - position;\r\n\tlet mt2: number = mt1 * mt1;\r\n\tlet mt3: number = mt2 * mt1;\r\n\r\n\tpoint.x = pointA.x * mt3 + controlPointA.x * 3 * mt2 * position + controlPointB.x * 3 * mt1 * position * position + pointB.x * position * position * position;\r\n\tpoint.y = pointA.y * mt3 + controlPointA.y * 3 * mt2 * position + controlPointB.y * 3 * mt1 * position * position + pointB.y * position * position * position;\r\n\r\n\treturn point;\r\n}\r\n\r\n/**\r\n * [getCubicControlPointA description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\r\nexport function getCubicControlPointA(p0: IPoint, p1: IPoint, p2: IPoint, p3: IPoint, tensionX: number, tensionY: number): IPoint {\r\n\ttensionX = adjustTension(tensionX);\r\n\ttensionY = adjustTension(tensionY);\r\n\treturn { x: ((-p0.x + p1.x / tensionX + p2.x) * tensionX), y: ((-p0.y + p1.y / tensionY + p2.y) * tensionY) };\r\n}\r\n\r\n/**\r\n * [getCubicControlPointB description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\r\nexport function getCubicControlPointB(p0: IPoint, p1: IPoint, p2: IPoint, p3: IPoint, tensionX: number, tensionY: number): IPoint {\r\n\ttensionX = adjustTension(tensionX);\r\n\ttensionY = adjustTension(tensionY);\r\n\treturn { x: ((p1.x + p2.x / tensionX - p3.x) * tensionX), y: ((p1.y + p2.y / tensionY - p3.y) * tensionY) };\r\n}\r\n\r\n/**\r\n * [adjustTension description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param tension  [description]\r\n * @return [description]\r\n */\r\nexport function adjustTension(tension: number): number {\r\n\treturn 1 - tension + 0.00001;\r\n}\r\n\r\n/**\r\n * [normalizeAngle description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param value  [description]\r\n * @return [description]\r\n */\r\nexport function normalizeAngle(value: number): number {\r\n\tif (value == 360) {\r\n\t\treturn 360;\r\n\t}\r\n\treturn value % 360;\r\n}\r\n\r\n\r\n\r\n/**\r\n * [normalizeAngleToRange description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @todo review this with various angles, can be tested on radar chart with custom start/end angles\r\n * @param value       [description]\r\n * @param startAngle  [description]\r\n * @param endAngle    [description]\r\n * @return [description]\r\n */\r\nexport function fitAngleToRange(value: number, startAngle: number, endAngle: number): number {\r\n\r\n\tif (startAngle > endAngle) {\r\n\t\tlet temp: number = startAngle;\r\n\t\tstartAngle = endAngle;\r\n\t\tendAngle = temp;\r\n\t}\r\n\r\n\tvalue = normalizeAngle(value);\r\n\r\n\tlet count = (startAngle - normalizeAngle(startAngle)) / 360;\r\n\r\n\tif (value < startAngle) {\r\n\t\tvalue += 360 * (count + 1);\r\n\t}\r\n\r\n\tlet maxEnd: number = startAngle + (endAngle - startAngle) / 2 + 180;\r\n\tlet maxStart: number = startAngle + (endAngle - startAngle) / 2 - 180;\r\n\r\n\tif (value > endAngle) {\r\n\r\n\t\tif (value - 360 > startAngle) {\r\n\t\t\tvalue -= 360;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (value < maxEnd) {\r\n\t\t\t\tvalue = endAngle;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalue = startAngle;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (value < startAngle) {\r\n\t\tif (value > maxStart) {\r\n\t\t\tvalue = startAngle;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tvalue = endAngle;\r\n\t\t}\r\n\t}\r\n\r\n\treturn value;\r\n}\r\n\r\n\r\n/**\r\n * Returns [[IRectangle]] of an arc in relative values, assuming that the\r\n * center is at the circle center.\r\n *\r\n * Used to find out max radius of an arc.\r\n *\r\n * @ignore Exclude from docs\r\n * @param startAngle  Start angle\r\n * @param endAngle    End angle\r\n * @param radius    \t Relative radius\r\n * @return Rectangle\r\n */\r\nexport function getArcRect(startAngle: number, endAngle: number, radius?: number): IRectangle {\r\n\r\n\tlet minX = Number.MAX_VALUE;\r\n\tlet minY = Number.MAX_VALUE;\r\n\tlet maxX = -Number.MAX_VALUE;\r\n\tlet maxY = -Number.MAX_VALUE;\r\n\r\n\tlet bpoints = [];\r\n\r\n\tif (!$type.isNumber(radius)) {\r\n\t\tradius = 1;\r\n\t}\r\n\r\n\tbpoints.push(getArcPoint(radius, startAngle));\r\n\tbpoints.push(getArcPoint(radius, endAngle));\r\n\r\n\tlet fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\r\n\tlet toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\r\n\r\n\tfor (let angle = fromAngle; angle <= toAngle; angle += 90) {\r\n\t\tif (angle >= startAngle && angle <= endAngle) {\r\n\t\t\tbpoints.push(getArcPoint(radius, angle));\r\n\t\t}\r\n\t}\r\n\r\n\tfor (let i = 0; i < bpoints.length; i++) {\r\n\t\tlet pt = bpoints[i];\r\n\t\tif (pt.x < minX) { minX = pt.x; }\r\n\t\tif (pt.y < minY) { minY = pt.y; }\r\n\t\tif (pt.x > maxX) { maxX = pt.x; }\r\n\t\tif (pt.y > maxY) { maxY = pt.y; }\r\n\t}\r\n\r\n\treturn ({ x: minX, y: minY, width: maxX - minX, height: maxY - minY });\r\n}\r\n\r\n/**\r\n * Returns point on arc\r\n *\r\n * @param center point\r\n * @param radius\r\n * @param arc\r\n * @return {boolean}\r\n */\r\nexport function getArcPoint(radius: number, arc: number) {\r\n\treturn ({ x: radius * cos(arc), y: radius * sin(arc) });\r\n}\r\n\r\n/**\r\n * Returns true if a point is within rectangle\r\n *\r\n * @param point\r\n * @param rectangle\r\n * @return {boolean}\r\n */\r\nexport function isInRectangle(point: IPoint, rectangle: IRectangle): boolean {\r\n\tif (point.x >= rectangle.x && point.x <= rectangle.x + rectangle.width && point.y > rectangle.y && point.y < rectangle.y + rectangle.height) {\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n\r\nexport function getLineIntersection(pointA1: IPoint, pointA2: IPoint, pointB1: IPoint, pointB2: IPoint) {\r\n\tlet x = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.x - pointB2.x) - (pointA1.x - pointA2.x) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));\r\n\tlet y = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));\r\n\treturn { x: x, y: y };\r\n}\r\n","/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Ordering } from \"./Order\";\r\nimport { Optional } from \"./Type\";\r\nimport * as $math from \"./Math\";\r\nimport * as $type from \"./Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * UTILITY FUNCTIONS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Searches `array` for `value`.\r\n *\r\n * Returns -1 if not found.\r\n *\r\n * @param array  Source array\r\n * @param value  Value to search\r\n * @returns Index\r\n */\r\nexport function indexOf<A>(array: ArrayLike<A>, value: A): number {\r\n\tconst length = array.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\t// TODO handle NaN\r\n\t\tif (array[i] === value) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\r\n\treturn -1;\r\n}\r\n\r\n/**\r\n * Calls `test` for each element in `array`.\r\n *\r\n * If `test` returns `true` then it immediately returns `true`.\r\n *\r\n * If `test` returns `false` for all of the elements in `array` then it returns `false`.\r\n *\r\n * @param array  Source array\r\n * @param test   Function which is called on each element\r\n * @returns Whether `test` returned true or not\r\n */\r\nexport function any<A>(array: ArrayLike<A>, test: (value: A) => boolean): boolean {\r\n\tconst length = array.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\tif (test(array[i])) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n/**\r\n * Calls `fn` function for every member of array and returns a new array out\r\n * of all outputs.\r\n *\r\n * @param array  Source array\r\n * @param fn     Callback function\r\n * @returns New array\r\n */\r\nexport function map<A, B>(array: ArrayLike<A>, fn: (value: A, index: number) => B): Array<B> {\r\n\tconst length = array.length;\r\n\tconst output = new Array(length);\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\toutput[i] = fn(array[i], i);\r\n\t}\r\n\r\n\treturn output;\r\n}\r\n\r\n/**\r\n * Iterates through all items in array and calls `fn` function for each of\r\n * them.\r\n *\r\n * @param array  Source array\r\n * @param fn     Callback function\r\n */\r\nexport function each<A>(array: ArrayLike<A>, fn: (value: A, index: number) => void): void {\r\n\tconst length = array.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\tfn(array[i], i);\r\n\t}\r\n}\r\n\r\n/**\r\n * Iterates through all items in array in reverse order and calls `fn` function for each of\r\n * them.\r\n *\r\n * @param array  Source array\r\n * @param fn     Callback function\r\n */\r\nexport function eachReverse<A>(array: ArrayLike<A>, fn: (value: A, index: number) => void): void {\r\n\tlet i = array.length;\r\n\r\n\twhile (i--) {\r\n\t\tfn(array[i], i);\r\n\t}\r\n}\r\n\r\n/**\r\n * Iterates through all items in array and calls `fn` function for each of\r\n * them.\r\n *\r\n * If `fn` call evaluates to `false`, further iteration is cancelled.\r\n *\r\n * @param array  Source array\r\n * @param fn     Callback function\r\n */\r\nexport function eachContinue<A>(array: ArrayLike<A>, fn: (value: A, index: number) => boolean): void {\r\n\tconst length = array.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\tif (!fn(array[i], i)) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Shifts an item at `index` towards beginning of the array.\r\n *\r\n * @param array  Source array\r\n * @param index  Target element index\r\n */\r\nexport function shiftLeft<A>(array: Array<A>, index: number): void {\r\n\tconst length = array.length;\r\n\r\n\tfor (let i = index; i < length; ++i) {\r\n\t\tarray[i - index] = array[i];\r\n\t}\r\n\r\n\tarray.length = length - index;\r\n}\r\n\r\n/**\r\n * Returns the last item of the array.\r\n *\r\n * @param array  Source array\r\n * @returns Last item\r\n */\r\nexport function last<A>(array: Array<A>): Optional<A> {\r\n\tconst length = array.length;\r\n\treturn length ? array[length - 1] : undefined;\r\n}\r\n\r\n/**\r\n * Returns the first item of the array.\r\n *\r\n * @param array  Source array\r\n * @returns Last item\r\n */\r\nexport function first<A>(array: Array<A>): Optional<A> {\r\n\treturn array[0];\r\n}\r\n\r\n/**\r\n * Inserts `element` into `array` at `index`.\r\n *\r\n * Caps `index` to be between `0` and `array.length`\r\n *\r\n * @param array    Source array\r\n * @param element  Item to insert\r\n * @param array    Index to insert item at\r\n */\r\nexport function insert<A>(array: Array<A>, element: A, index: number): void {\r\n\t//if (array) {\r\n\tindex = $math.fitToRange(index, 0, array.length);\r\n\tarray.splice(index, 0, element);\r\n\t//}\r\n}\r\n\r\n/**\r\n * Removes all copies of `element` from `array` (if they exist) and then\r\n * inserts `element` at `index`.\r\n *\r\n * @param array    Source array\r\n * @param element  Item\r\n * @param array    Index to move item to\r\n */\r\nexport function setIndex<A>(array: Array<A>, element: A, index: number): void {\r\n\tremove(array, element);\r\n\tinsert(array, element, index);\r\n}\r\n\r\n\r\n/**\r\n * Pushes all of the elements from `input` into `array`.\r\n *\r\n * @param array  Output array\r\n * @param input  Input array\r\n */\r\nexport function pushAll<A>(array: Array<A>, input: Array<A>) {\r\n\tconst length = input.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\tarray.push(input[i]);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Removes `element` from `array`.\r\n *\r\n * If there are multiple copies of `element`, they are all removed.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to remove\r\n */\r\nexport function remove<A>(array: Array<A>, element: A): boolean {\r\n\tlet found: boolean = false;\r\n\tlet index: number = array.indexOf(element);\r\n\r\n\tif (index !== -1) {\r\n\t\tfound = true;\r\n\t\tarray.splice(index, 1);\r\n\r\n\t\tlet length: number = array.length;\r\n\r\n\t\twhile (index < length) {\r\n\t\t\t// TODO handle NaN\r\n\t\t\tif (array[index] === element) {\r\n\t\t\t\tarray.splice(index, 1);\r\n\t\t\t\t--length;\r\n\r\n\t\t\t} else {\r\n\t\t\t\t++index;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn found;\r\n}\r\n\r\n/**\r\n * Adds an `element` to `array`.\r\n *\r\n * If array already contains and item like this, it is removed before adding\r\n * it again.\r\n *\r\n * Optionally `toIndex` can be specified to add element at specific index.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to add\r\n * @param array    Index to move item to\r\n */\r\nexport function move<A>(array: Array<A>, element: A, toIndex?: number): void {\r\n\t// @todo this implementation must be the same as the List.moveValue method\r\n\t// @todo don't do anything if the desired index is the same as the current index\r\n\tlet index = indexOf(array, element);\r\n\r\n\t// @todo remove all old values rather than only the first ?\r\n\tif (index !== -1) {\r\n\t\tremoveIndex(array, index);\r\n\t}\r\n\r\n\tif (toIndex == null) {\r\n\t\tarray.push(element);\r\n\t} else {\r\n\t\tinsertIndex(array, toIndex, element);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Inserts `element` into `array` at `index`.\r\n *\r\n * If `index` is not provided, it will insert `element` at the end of `array`.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to add\r\n * @param array    Index to add item at\r\n */\r\nexport function add<A>(array: Array<A>, element: A, index?: number): void {\r\n\t// Append to the end if index is not set\r\n\tif (!$type.isNumber(index)) {\r\n\t\tarray.push(element);\r\n\t}\r\n\r\n\t// Add to the beginning of array if index is 0\r\n\telse if (index === 0) {\r\n\t\tarray.unshift(element);\r\n\t}\r\n\t// Add to indicated place if index is set\r\n\telse {\r\n\t\tarray.splice(index, 0, element);\r\n\t}\r\n}\r\n\r\n/**\r\n * Removes `element` from `array` (if it exists) and then inserts `element` at\r\n * `index`.\r\n *\r\n * If `index` is not provided, it will insert `element` at the end of `array`.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to remove\r\n * @param array    Index to move item to\r\n */\r\nexport function replace<A>(array: Array<A>, element: A, index?: number): void {\r\n\t// check if exists\r\n\tlet ind: number = array.indexOf(element);\r\n\r\n\t// remove if exists\r\n\tif (ind !== -1) {\r\n\t\tarray.splice(ind, 1);\r\n\t}\r\n\r\n\t// add to end if index is not set\r\n\tif (!$type.isNumber(index)) {\r\n\t\tarray.push(element);\r\n\t}\r\n\t// add to indicated place if index is set\r\n\telse {\r\n\t\tarray.splice(index, 0, element);\r\n\t}\r\n}\r\n\r\n/**\r\n * Wraps `input` in an array, if it isn't already an array.\r\n *\r\n * @param input  Source value\r\n * @return An array\r\n */\r\nexport function toArray<A>(input: Array<A> | A): Array<A> {\r\n\tif (Array.isArray(input)) {\r\n\t\treturn input;\r\n\t}\r\n\telse {\r\n\t\treturn [input];\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns `true` if `element` exists in `array`.\r\n *\r\n * @param array    Source array\r\n * @param element  Item to search for\r\n * @returns Item in array?\r\n */\r\nexport function has<A>(array: ArrayLike<A>, element: A): boolean {\r\n\treturn indexOf(array, element) !== -1;\r\n}\r\n\r\n/**\r\n * Returns a shallow copy of `array`.\r\n *\r\n * @param array  Source array\r\n * @returns Copy of the array\r\n */\r\nexport function copy<A>(array: ArrayLike<A>): Array<A> {\r\n\tconst length = array.length;\r\n\r\n\t// It's faster to create the array with a pre-defined length\r\n\tconst output = new Array(length);\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\t// Because the array has a pre-defined length, we have to assign rather than push\r\n\t\t// This is also faster than pushing\r\n\t\toutput[i] = array[i];\r\n\t}\r\n\r\n\treturn output;\r\n}\r\n\r\n\r\n/**\r\n * Returns a copy of `array` which contains all the elements between `start`\r\n * and `end`. (including `start` and excluding `end`)\r\n *\r\n * If `end` is not provided, it defaults to `array.length`.\r\n *\r\n * @param array  Source array\r\n * @param start  Start index\r\n * @param end    End index\r\n * @returns Part of the array\r\n */\r\nexport function slice<A>(array: ArrayLike<A>, start: number, end: number = array.length): Array<A> {\r\n\tconst output = new Array(end - start);\r\n\r\n\tfor (let i = start; i < end; ++i) {\r\n\t\toutput[i - start] = array[i];\r\n\t}\r\n\r\n\treturn output;\r\n}\r\n\r\n/**\r\n * Inserts a value into array at specific index.\r\n *\r\n * @param array  Source array\r\n * @param index  Index\r\n * @param value  Value to insert\r\n */\r\nexport function insertIndex<A>(array: Array<A>, index: number, value: A): void {\r\n\tarray.splice(index, 0, value);\r\n}\r\n\r\n/**\r\n * Removes a value from array at specific index.\r\n *\r\n * @param array  Source array\r\n * @param index  Index\r\n */\r\nexport function removeIndex<A>(array: Array<A>, index: number): void {\r\n\tarray.splice(index, 1);\r\n}\r\n\r\n/**\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nexport interface SortResult {\r\n\tfound: boolean;\r\n\tindex: number\r\n}\r\n\r\n/**\r\n * Orders an array using specific `ordering` function and returns index of\r\n * the `value`.\r\n *\r\n * @ignore Exclude from docs\r\n * @param array     Source array\r\n * @param ordering  An ordering function\r\n * @param value     Value to search for\r\n * @returns Result of the search\r\n */\r\nexport function getSortedIndex<A>(array: ArrayLike<A>, ordering: (left: A, right: A) => Ordering, value: A): SortResult {\r\n\tlet start = 0;\r\n\tlet end   = array.length;\r\n\tlet found = false;\r\n\r\n\twhile (start < end) {\r\n\t\t// TODO is this faster/slower than using Math.floor ?\r\n\t\tconst pivot = (start + end) >> 1;\r\n\r\n\t\tconst order = ordering(value, array[pivot]);\r\n\r\n\t\t// less\r\n\t\tif (order < 0) {\r\n\t\t\tend = pivot;\r\n\r\n\t\t// equal\r\n\t\t} else if (order === 0) {\r\n\t\t\tfound = true;\r\n\t\t\tstart = pivot + 1;\r\n\r\n\t\t// more\r\n\t\t} else {\r\n\t\t\tstart = pivot + 1;\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tfound: found,\r\n\t\tindex: (found ? start - 1 : start)\r\n\t};\r\n}\r\n\r\n/**\r\n * Searches the array using custom function and returns index of the item if\r\n * found.\r\n *\r\n * Will call `matches` function on all items of the array. If return value\r\n * evaluates to `true`, index is returned.\r\n *\r\n * Otherwise returns -1.\r\n *\r\n * @param array    Source array\r\n * @param matches  Search function\r\n * @returns Index of the item if found\r\n */\r\nexport function findIndex<A>(array: ArrayLike<A>, matches: (value: A, index: number) => boolean): number {\r\n\tconst length = array.length;\r\n\r\n\tfor (let i = 0; i < length; ++i) {\r\n\t\tif (matches(array[i], i)) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\r\n\treturn -1;\r\n}\r\n\r\n/**\r\n * Searches the array using custom function and returns item if found.\r\n *\r\n * Will call `matches` function on all items of the array. If return value\r\n * evaluates to `true`, index is returned.\r\n *\r\n * Otherwise returns `undefined`.\r\n *\r\n * @param array    Source array\r\n * @param matches  Search function\r\n * @returns Item if found\r\n */\r\nexport function find<A>(array: ArrayLike<A>, matches: (value: A, index: number) => boolean): A | undefined {\r\n\tconst index = findIndex(array, matches);\r\n\r\n\tif (index !== -1) {\r\n\t\treturn array[index];\r\n\t}\r\n}\r\n\r\n/**\r\n * Iterates through all items in array and calls `fn` function for each of\r\n * them.\r\n *\r\n * @param array  Source array\r\n * @param fn     Callback function\r\n */\r\nexport function shuffle<A>(array: Array<A>) {\r\n\t// https://stackoverflow.com/a/2450976/449477\r\n\tlet currentIndex = array.length,\r\n\t\ttemporaryValue,\r\n\t\trandomIndex;\r\n\r\n\t// While there remain elements to shuffle...\r\n\twhile (0 !== currentIndex) {\r\n\t\t// Pick a remaining element...\r\n\t\trandomIndex = Math.floor(Math.random() * currentIndex);\r\n\t\tcurrentIndex -= 1;\r\n\r\n\t\t// And swap it with the current element.\r\n\t\ttemporaryValue = array[currentIndex];\r\n\t\tarray[currentIndex] = array[randomIndex];\r\n\t\tarray[randomIndex] = temporaryValue;\r\n\t}\r\n}\r\n\r\n\r\nexport function keepIf<A>(array: Array<A>, keep: (value: A) => boolean): void {\r\n\tlet length = array.length;\r\n\tlet i = 0;\r\n\r\n\twhile (i < length) {\r\n\t\tif (keep(array[i])) {\r\n\t\t\t++i;\r\n\r\n\t\t} else {\r\n\t\t\tarray.splice(i, 1);\r\n\t\t\t--length;\r\n\t\t}\r\n\t}\r\n}\r\n","/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport * as $array from \"./Array\";\r\nimport * as $type from \"./Type\";\r\nimport { Optional } from \"./Type\";\r\n\r\n/**\r\n * Defines interface for disposable objects.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport interface IDisposer {\r\n\tisDisposed(): boolean;\r\n\tdispose(): void;\r\n}\r\n\r\n/**\r\n * A base class for disposable objects.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport class Disposer implements IDisposer {\r\n\r\n\t/**\r\n\t * Is object disposed?\r\n\t */\r\n\tprivate _disposed: boolean;\r\n\r\n\t/**\r\n\t * Method that disposes the object.\r\n\t */\r\n\tprivate _dispose: () => void;\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t *\r\n\t * @param dispose  Function that disposes object\r\n\t */\r\n\tconstructor(dispose: () => void) {\r\n\t\tthis._disposed = false;\r\n\t\tthis._dispose = dispose;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if object is disposed.\r\n\t *\r\n\t * @return Disposed?\r\n\t */\r\n\tpublic isDisposed(): boolean {\r\n\t\treturn this._disposed;\r\n\t}\r\n\r\n\t/**\r\n\t * Disposes the object.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tif (!this._disposed) {\r\n\t\t\tthis._disposed = true;\r\n\t\t\tthis._dispose();\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * A collection of related disposers that can be disposed in one go.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport class MultiDisposer extends Disposer {\r\n\tconstructor(disposers: Array<IDisposer>) {\r\n\t\tsuper(() => {\r\n\t\t\t$array.each(disposers, (x) => {\r\n\t\t\t\tx.dispose();\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n}\r\n\r\n/**\r\n * A special kind of Disposer that has attached value set.\r\n *\r\n * If a new value is set using `set()` method, the old disposer value is\r\n * disposed.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nexport class MutableValueDisposer<T extends IDisposer> extends Disposer {\r\n\r\n\t/**\r\n\t * Current disposer.\r\n\t */\r\n\tprivate _disposer: Optional<IDisposer>;\r\n\r\n\t/**\r\n\t * Current value.\r\n\t */\r\n\tprivate _value: Optional<T>;\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper(() => {\r\n\t\t\tif ($type.hasValue(this._disposer)) {\r\n\t\t\t\tthis._disposer.dispose();\r\n\t\t\t\tthis._disposer = undefined;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returns current value.\r\n\t *\r\n\t * @return Value\r\n\t */\r\n\tpublic get(): Optional<T> {\r\n\t\treturn this._value;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets value and disposes previous disposer if it was set.\r\n\t *\r\n\t * @param value     New value\r\n\t * @param disposer  Disposer\r\n\t */\r\n\tpublic set(value: Optional<T>, disposer: Optional<IDisposer>): void {\r\n\t\tif ($type.hasValue(this._disposer)) {\r\n\t\t\tthis._disposer.dispose();\r\n\t\t}\r\n\r\n\t\tthis._disposer = disposer;\r\n\t\tthis._value = value;\r\n\t}\r\n\r\n\t/**\r\n\t * Resets the disposer value.\r\n\t */\r\n\tpublic reset(): void {\r\n\t\tthis.set(undefined, undefined);\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\r\nexport class CounterDisposer extends Disposer {\r\n\r\n\t/**\r\n\t * [_counter description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprivate _counter: number = 0;\r\n\r\n\t/**\r\n\t * [increment description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tpublic increment() {\r\n\t\t// TODO throw an error if it is disposed\r\n\t\t++this._counter;\r\n\r\n\t\t// TODO make this more efficient\r\n\t\treturn new Disposer(() => {\r\n\t\t\t--this._counter;\r\n\r\n\t\t\tif (this._counter === 0) {\r\n\t\t\t\tthis.dispose();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n}\r\n","/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\nimport { IClone } from \"./Clone\";\nimport { Ordering } from \"./Order\";\nimport * as $array from \"./Array\";\nimport * as $type from \"./Type\";\n\n\n/**\n * ============================================================================\n * UTILITY FUNCTIONS\n * ============================================================================\n * @hidden\n */\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport interface Iterator<A> {\n\t(push: (value: A) => boolean): void;\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport interface Iterable<A> {\n\titerator(): Iterator<A>;\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function fromArray<A>(array: Array<A>): Iterator<A> {\n\treturn (push) => {\n\t\tconst length = array.length;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tif (!push(array[i])) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function length<A>(iter: Iterator<A>): number {\n\tlet sum = 0;\n\n\titer((_) => {\n\t\t++sum;\n\t\treturn true;\n\t});\n\n\treturn sum;\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function toArray<A>(iter: Iterator<A>): Array<A> {\n\tconst output: Array<A> = [];\n\n\titer((value) => {\n\t\toutput.push(value);\n\t\treturn true;\n\t});\n\n\treturn output;\n}\n\n/**\n * [iter description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function eachContinue<A>(iter: Iterator<A>, fn: (value: A) => boolean): void {\n\titer(fn);\n}\n\n/**\n * [iter description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function each<A>(iter: Iterator<A>, fn: (value: A) => void): void {\n\titer((value) => {\n\t\tfn(value);\n\t\treturn true;\n\t});\n}\n\n/**\n * [iter description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function sort<A>(iter: Iterator<A>, fn: (left: A, right: A) => Ordering): Iterator<A> {\n\treturn fromArray(toArray(iter).sort(fn));\n}\n\n/**\n * [A description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function map<A, B>(iter: Iterator<A>, fn: (value: A) => B): Iterator<B> {\n\treturn (push) => iter((value) => push(fn(value)));\n}\n\n/**\n * [iter description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function filter<A>(iter: Iterator<A>, fn: (value: A) => boolean): Iterator<A> {\n\treturn (push) => iter((value) => {\n\t\tif (fn(value)) {\n\t\t\treturn push(value);\n\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t});\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function concat<A>(...args: Array<Iterator<A>>): Iterator<A> {\n\treturn (push) => {\n\t\tlet go = true;\n\n\t\tconst push2 = (value: A) => (go = push(value));\n\n\t\tconst length = args.length;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\targs[i](push2);\n\n\t\t\tif (!go) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function flatten<A>(iter: Iterator<Iterator<A>>): Iterator<A> {\n\treturn (push) => {\n\t\tlet go = true;\n\n\t\tconst push2 = (value: A) => (go = push(value));\n\n\t\titer((value) => {\n\t\t\tvalue(push2);\n\t\t\treturn go;\n\t\t});\n\t};\n}\n\n/**\n * [number description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function indexed<A>(iter: Iterator<A>): Iterator<[number, A]> {\n\treturn (push) => {\n\t\tlet index = 0;\n\n\t\titer((value) => push([index++, value]));\n\t};\n}\n\n/**\n * [iter description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function findIndex<A>(iter: Iterator<A>, matches: (value: A) => boolean): number {\n\tlet found = false;\n\tlet i = 0;\n\n\titer((value) => {\n\t\tif (matches(value)) {\n\t\t\tfound = true;\n\t\t\treturn false;\n\n\t\t} else {\n\t\t\t++i;\n\t\t\treturn true;\n\t\t}\n\t});\n\n\treturn (found ? i : -1);\n}\n\n/**\n * [iter description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function find<A>(iter: Iterator<A>, matches: (value: A) => boolean): A | undefined {\n\tlet output;\n\n\titer((value) => {\n\t\tif (matches(value)) {\n\t\t\toutput = value;\n\t\t\treturn false;\n\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t});\n\n\treturn output;\n}\n\n/**\n * [A description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function findMap<A, B>(iter: Iterator<A>, matches: (value: A) => B | null): B | undefined {\n\tlet output;\n\n\titer((value) => {\n\t\tconst v = matches(value);\n\n\t\tif (v !== null) {\n\t\t\toutput = v;\n\t\t\treturn false;\n\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t});\n\n\treturn output;\n}\n\n/**\n * [iter description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function contains<A>(iter: Iterator<A>, matches: (value: A) => boolean): boolean {\n\tlet output = false;\n\n\titer((value) => {\n\t\tif (matches(value)) {\n\t\t\toutput = true;\n\t\t\treturn false;\n\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t});\n\n\treturn output;\n}\n\n/**\n * [A description]\n *\n * @ignore Exclude from docs\n * @todo Description\n */\nexport function foldl<A, B>(iter: Iterator<A>, init: B, fn: (state: B, value: A) => B): B {\n\titer((value) => {\n\t\tinit = fn(init, value);\n\t\treturn true;\n\t});\n\n\treturn init;\n}\n\n/**\n * [min2 description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param left [description]\n * @param right [description]\n * @return [description]\n */\nfunction min2(left: number | null, right: number): number {\n\tif (left == null || right < left) {\n\t\treturn right;\n\n\t} else {\n\t\treturn left;\n\t}\n}\n\n/**\n * [min description]\n *\n * @ignore Exclude from docs\n * @todo Verify that this works correctly\n * @todo Description\n * @param a [description]\n * @return [description]\n */\nexport function min(a: Iterator<number>): number | null {\n\treturn foldl(a, null, min2);\n}\n\n/**\n * [max2 description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param left [description]\n * @param right [description]\n * @return [description]\n */\nfunction max2(left: number | null, right: number): number {\n\tif (left == null || right > left) {\n\t\treturn right;\n\n\t} else {\n\t\treturn left;\n\t}\n}\n\n/**\n * [max description]\n *\n * @ignore Exclude from docs\n * @todo Verify that this works correctly\n * @todo Description\n * @param a [description]\n * @return [description]\n */\nexport function max(a: Iterator<number>): number | null {\n\treturn foldl(a, null, max2);\n}\n\n\n/**\n * [join description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param iter [description]\n * @param separator [description]\n * @return [description]\n */\nexport function join(iter: Iterator<string>, separator: string = \"\"): string {\n\tlet first = true;\n\tlet init = \"\";\n\n\titer((value) => {\n\t\tif (first) {\n\t\t\tfirst = false;\n\n\t\t} else {\n\t\t\tinit += separator;\n\t\t}\n\n\t\tinit += value;\n\n\t\treturn true;\n\t});\n\n\treturn init;\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport class ListIterator<T extends IClone<T>> {\n\tprivate _listCopy!: Array<T>;\n\tprivate _create: () => T;\n\n\tpublic list: Iterable<T>;\n\n\t// flag specifies if iterator should create new list item if it is reqested for a nextItem but there is no more left in the list\n\tpublic createNewItems: boolean = false;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param list [description]\n\t * @param create [description]\n\t */\n\tconstructor(list: Iterable<T>, create: () => T) {\n\t\tthis.list = list;\n\t\tthis._create = create;\n\t\tthis.reset();\n\t}\n\n\treset() {\n\t\tthis._listCopy = toArray(this.list.iterator());\n\t}\n\n\tclear() {\n\t\tthis._listCopy.length = 0;\n\t}\n\n\tgetFirst(): $type.Optional<T> {\n\t\treturn this.returnItem(0);\n\t}\n\n\tgetLast(): $type.Optional<T> {\n\t\treturn this.returnItem(this._listCopy.length - 1);\n\t}\n\n\tfind(fn: (value: T) => boolean): $type.Optional<T> {\n\t\tlet index: number = $array.findIndex(this._listCopy, fn);\n\n\t\tif (index !== -1) {\n\t\t\tlet item = this._listCopy[index];\n\t\t\t// TODO use removeIndex instead ?\n\t\t\t$array.remove(this._listCopy, item);\n\t\t\treturn item;\n\n\t\t} else {\n\t\t\treturn this.getLast();\n\t\t}\n\t}\n\n\tremoveItem(item: T): boolean {\n\t\treturn $array.remove(this._listCopy, item);\n\t}\n\n\tprotected returnItem(index: number): $type.Optional<T> {\n\t\tif (index >= 0 && index < this._listCopy.length) {\n\t\t\tlet item = this._listCopy[index];\n\t\t\t// TODO use removeIndex instead ?\n\t\t\t$array.remove(this._listCopy, item);\n\t\t\treturn item;\n\n\t\t} else if (this.createNewItems) {\n\t\t\treturn this._create();\n\t\t}\n\t}\n\n\titerator() {\n\t\treturn fromArray(this._listCopy);\n\t}\n}\n","/**\n * ============================================================================\n * MAIN CLASS\n * ============================================================================\n * @hidden\n */\n\n/**\n * Represents a relative value (percent).\n *\n * The Percent object, can be instantiated using two ways:\n *\n * * Via `new Percent(X)`.\n * * Via `am4core.percent(X)`.\n *\n * `Percent` type objects can be used in a number of dual-measuring or\n * positioning properties, like `width`. E.g.:\n *\n * ```TypeScript\n * chart.paddingRight = new Percent(10);\n * // or\n * chart.paddingRight = am4core.percent(10);\n * ```\n * ```JavaScript\n * chart.paddingRight = new Percent(10);\n * // or\n * chart.paddingRight = am4core.percent(10);\n * ```\n * ```JSON\n * {\n *   // ...\n *   \"paddingRight\": \"10%\"\n * }\n * ```\n */\nexport class Percent {\n\n\t/**\n\t * Value in percent.\n\t */\n\tprotected _value: number;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @param percent  Percent value\n\t */\n\tconstructor(percent: number) {\n\t\tthis._value = percent;\n\t}\n\n\t/**\n\t * Relative value.\n\t *\n\t * E.g. 100% is 1, 50% is 0.5, etc.\n\t *\n\t * This is useful to apply transformations to other values. E.g.:\n\t *\n\t * ```TypeScript\n\t * let value = 256;\n\t * let percent = new am4core.Percent(50);\n\t * console.log(value * percent.value); // outputs 128\n\t * ```\n\t * ```JavaScript\n\t * var value = 256;\n\t * var percent = new am4core.Percent(50);\n\t * console.log(value * percent.value); // outputs 128\n\t * ```\n\t *\n\t * Alternatively, you can use `am4core.percent()` helper function:\n\t *\n\t * ```TypeScript\n\t * let value = 256;\n\t * let percent = am4core.percent(50);\n\t * console.log(value * percent.value); // outputs 128\n\t * ```\n\t * ```JavaScript\n\t * var value = 256;\n\t * var percent = am4core.percent(50);\n\t * console.log(value * percent.value); // outputs 128\n\t * ```\n\t *\n\t * @readonly\n\t * @return Relative value\n\t */\n\tpublic get value(): number {\n\t\treturn this._value / 100;\n\t}\n\n\t/**\n\t * Value in percent.\n\t *\n\t * @return Percent\n\t */\n\tpublic get percent(): number {\n\t\treturn this._value;\n\t}\n\n\tpublic toString(): string {\n\t\treturn \"\" + this._value + \"%\";\n\t}\n\n\t/*public toNumber(): number {\n\t\treturn this.percent;\n\t}*/\n\n}\n\n\n/**\n * Converts numeric percent value to a proper [[Percent]] object.\n *\n * ```TypeScript\n * pieSeries.radius = am4core.percent(80);\n * ```\n * ```JavaScript\n * pieSeries.radius = am4core.percent(80);\n * ```\n *\n * @param value  Percent\n * @return Percent object\n */\nexport function percent(value: number): Percent {\n\treturn new Percent(value);\n}\n\n\n/**\n * Checks if value is a [[Percent]] object.\n *\n * @ignore Exclude from docs\n * @param value  Input value\n * @return Is percent?\n */\nexport function isPercent(value: any): boolean {\n\treturn value instanceof Percent;\n}\n","/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport * as $array from \"./Array\";\r\nimport * as $iter from \"./Iterator\";\r\nimport * as $type from \"./Type\";\r\nimport { Ordering } from \"./Order\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * UTILITY FUNCTIONS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Returns an iterator for all entries in object.\r\n *\r\n * Can be used to safely iterate through all properties of the object.\r\n *\r\n * @param object  Source object\r\n * @returns Iterator\r\n */\r\nexport function entries<Object>(object: Object): $iter.Iterator<[$type.Keyof<Object>, Object[$type.Keyof<Object>]]> {\r\n\treturn (push) => {\r\n\t\t// TODO make this more efficient ?\r\n\t\tfor (let key in object) {\r\n\t\t\tif (hasKey(object, key)) {\r\n\t\t\t\tif (!push([key as $type.Keyof<Object>, object[key] as Object[$type.Keyof<Object>]])) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n * Returns an array of object's property names.\r\n *\r\n * @param object  Source object\r\n * @returns Object property names\r\n */\r\nexport function keys<Object>(object: Object): Array<$type.Keyof<Object>> {\r\n\tconst output = [];\r\n\r\n\tfor (let key in object) {\r\n\t\tif (hasKey(object, key)) {\r\n\t\t\toutput.push(key as $type.Keyof<Object>);\r\n\t\t}\r\n\t}\r\n\r\n\treturn output;\r\n}\r\n\r\n/**\r\n * Returns an array of object's property names ordered using specific ordering\r\n * function.\r\n *\r\n * @param object  Source object\r\n * @param order   Ordering function\r\n * @returns Object property names\r\n */\r\nexport function keysOrdered<Object>(object: Object, order: (a: $type.Keyof<Object>, b: $type.Keyof<Object>) => Ordering): Array<$type.Keyof<Object>> {\r\n\treturn keys(object).sort(order);\r\n}\r\n\r\n/**\r\n * Checks if `object` has a specific `key`.\r\n *\r\n * @param object  Source object\r\n * @param key     Property name\r\n * @returns Has key?\r\n */\r\nexport function hasKey<Object, Key extends keyof Object>(object: Object, key: Key): boolean {\r\n\treturn {}.hasOwnProperty.call(object, key);\r\n}\r\n\r\n/**\r\n * Returns value of the specific `key`.\r\n *\r\n * @param object  Source object\r\n * @param key     Property name\r\n * @returns Key value\r\n */\r\nexport function getKey<Object, Key extends keyof Object>(object: Object, key: Key): Object[Key] {\r\n\treturn object[key];\r\n}\r\n\r\n/**\r\n * Iterates through all properties of the object calling `fn` for each of them.\r\n *\r\n * If return value of the function evaluates to `false` further iteration is\r\n * cancelled.\r\n *\r\n * @param object  Source object\r\n * @param fn      Callback function\r\n */\r\nexport function eachContinue<Object>(object: Object, fn: <Key extends $type.Keyof<Object>>(key: Key, value: Object[Key]) => boolean): void {\r\n\tfor (let key in object) {\r\n\t\tif (hasKey(object, key)) {\r\n\t\t\tif (!fn(key as $type.Keyof<Object>, object[key] as Object[$type.Keyof<Object>])) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Iterates through all properties of the object calling `fn` for each of them.\r\n *\r\n * @param object  Source object\r\n * @param fn      Callback function\r\n */\r\nexport function each<Object>(object: Object, fn: <Key extends $type.Keyof<Object>>(key: Key, value: Object[Key]) => void): void {\r\n\teachContinue(object, (key, value) => {\r\n\t\tfn(key, value);\r\n\t\treturn true;\r\n\t});\r\n}\r\n\r\n/**\r\n * Orders object properties using custom `ord` function and iterates through\r\n * them calling `fn` for each of them.\r\n *\r\n * @param object  Source object\r\n * @param fn      Callback function\r\n * @param order   Ordering function\r\n */\r\nexport function eachOrdered<Object>(object: Object, fn: <Key extends $type.Keyof<Object>>(key: Key, value: Object[Key]) => void, ord: (a: $type.Keyof<Object>, b: $type.Keyof<Object>) => Ordering): void {\r\n\t$array.each(keysOrdered(object, ord), (key) => {\r\n\t\tfn(key, object[key]);\r\n\t});\r\n}\r\n\r\n/**\r\n * Returns a copy of the object.\r\n *\r\n * @param object  Source object\r\n * @returns Copy of the object\r\n */\r\nexport function copy<Object>(object: Object): Object {\r\n\treturn Object.assign({}, object);\r\n}\r\n\r\n/**\r\n * Merges two objects and returns a new object that contains properties from\r\n * both source objects.\r\n *\r\n * @param object1  Source object #1\r\n * @param object2  Source object #2\r\n * @returns Combined object\r\n */\r\nexport function merge<Object1, Object2>(object1: Object1, object2: Object2): Object1 & Object2 {\r\n\treturn Object.assign({}, object1, object2);\r\n}\r\n\r\n/**\r\n * Returns object clone.\r\n *\r\n * @param object  Source object\r\n * @returns       Clone\r\n */\r\nexport function clone<Object>(object: Object): Object {\r\n\treturn JSON.parse(JSON.stringify(object));\r\n}\r\n/**\r\n * Copies a list of properties from one object to another.\r\n *\r\n * Will not copy empty properties.\r\n *\r\n * @param source  Source object\r\n * @param target    Target object\r\n * @param keys  List of keys to copy\r\n */\r\nexport function copyProperties(source: { [key: string]: any }, target: { [key: string]: any }, keys: Array<string>): void {\r\n\t$array.each(keys, (key) => {\r\n\t\tif ($type.hasValue(source[key])) {\r\n\t\t\ttarget[key] = source[key];\r\n\t\t}\r\n\t});\r\n}\r\n\r\n/**\r\n * Copies a list of properties from one object to another only if target does't have value of the property set.\r\n *\r\n * Will not copy empty properties.\r\n *\r\n * @param source  Source object\r\n * @param target    Target object\r\n * @param keys  List of keys to copy\r\n */\r\nexport function softCopyProperties(source: { [key: string]: any }, target: { [key: string]: any }, keys: Array<string>): void {\r\n\t$array.each(keys, (key) => {\r\n\t\tif ($type.hasValue(source[key]) && !($type.hasValue((<any>target)[key]))) {\r\n\t\t\ttarget[key] = source[key];\r\n\t\t}\r\n\t});\r\n}\r\n\r\n/**\r\n * Copies a list of properties from one object to another.\r\n *\r\n * Will copy empty properties.\r\n *\r\n * @param source  Source object\r\n * @param target    Target object\r\n * @param keys  List of keys to copy\r\n */\r\nexport function forceCopyProperties(source: { [key: string]: any }, target: { [key: string]: any }, keys: Array<string>): void {\r\n\t$array.each(keys, (key) => {\r\n\t\ttarget[key] = source[key];\r\n\t});\r\n}\r\n\r\n/**\r\n * Copies all properties from one object to another.\r\n *\r\n * @param from  Source object\r\n * @param to    Target object\r\n */\r\nexport function copyAllProperties(from: { [key: string]: any }, to: { [key: string]: any }): void {\r\n\tcopyProperties(from, to, keys(from));\r\n}\r\n","/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { IDisposer, Disposer } from \"./Disposer\";\r\nimport { EventDispatcher, AMEvent } from \"./EventDispatcher\";\r\nimport { Optional } from \"./Type\";\r\nimport { IClone } from \"./Clone\";\r\nimport * as $object from \"./Object\";\r\nimport * as $iter from \"./Iterator\";\r\nimport * as $string from \"./String\";\r\n\r\n/**\r\n * Defines events from [[Dictionary]].\r\n */\r\nexport interface IDictionaryEvents<Key, Value> {\r\n\r\n\t/**\r\n\t * Invoked when an item is removed from the dictionary.\r\n\t */\r\n\tremoved: {\r\n\r\n\t\t/**\r\n\t\t * Removed value.\r\n\t\t */\r\n\t\toldValue: Value;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when dictionary is cleared.\r\n\t */\r\n\tcleared: {};\r\n\r\n\t/**\r\n\t * Invoked when `insertKey()` method is called.\r\n\t */\r\n\tinsertKey: {\r\n\r\n\t\t/**\r\n\t\t * Key.\r\n\t\t */\r\n\t\tkey: Key;\r\n\r\n\t\t/**\r\n\t\t * Added value.\r\n\t\t */\r\n\t\tnewValue: Value;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when `setKey()` method is called.\r\n\t */\r\n\tsetKey: {\r\n\r\n\t\t/**\r\n\t\t * Key.\r\n\t\t */\r\n\t\tkey: Key;\r\n\r\n\t\t/**\r\n\t\t * Removed value. (if overwriting)\r\n\t\t */\r\n\t\toldValue: Value;\r\n\r\n\t\t/**\r\n\t\t * Added value.\r\n\t\t */\r\n\t\tnewValue: Value;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when `removeKey()` method is called.\r\n\t */\r\n\tremoveKey: {\r\n\r\n\t\t/**\r\n\t\t * Key.\r\n\t\t */\r\n\t\tkey: Key;\r\n\r\n\t\t/**\r\n\t\t * Removed value.\r\n\t\t */\r\n\t\toldValue: Value;\r\n\r\n\t};\r\n\r\n}\r\n\r\n/**\r\n * [K description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Descirption\r\n */\r\nexport type DictionaryLike<K, A> = $iter.Iterable<[K, A]> & {\r\n\tevents: EventDispatcher<{ removed: { oldValue: A } }>;\r\n};\r\n\r\n/**\r\n * A disposable dictionary, which when disposed itself will call `dispose()`\r\n * method on all its items.\r\n */\r\nexport class DictionaryDisposer<K, A extends IDisposer> extends Disposer {\r\n\tconstructor(dict: DictionaryLike<K, A>) {\r\n\t\tconst disposer = dict.events.on(\"removed\", (x) => {\r\n\t\t\tx.oldValue.dispose();\r\n\t\t}, undefined, false);\r\n\r\n\t\tsuper(() => {\r\n\t\t\tdisposer.dispose();\r\n\r\n\t\t\t// TODO clear the dictionary ?\r\n\t\t\t$iter.each(dict.iterator(), (a) => {\r\n\t\t\t\tconst v = a[1];\r\n\t\t\t\tv.dispose();\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n}\r\n\r\n/**\r\n * A Dictionary is collection where values of some type can be mapped to\r\n * string keys.\r\n *\r\n * You might call it an \"associative list\" or \"associative array\".\r\n */\r\nexport class Dictionary<Key extends string, T> {\r\n\r\n\t/**\r\n\t * Key/value pairs\r\n\t */\r\n\tprivate _dictionary: { [key in Key]?: T };\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t */\r\n\tpublic events: EventDispatcher<AMEvent<Dictionary<Key, T>, IDictionaryEvents<Key, T>>> = new EventDispatcher();\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tthis._dictionary = {};\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if key exists in Dictionary.\r\n\t *\r\n\t * @param key  The key to search for\r\n\t * @return `true` if key exists, `false` if it doesn't\r\n\t */\r\n\tpublic hasKey(key: Key): boolean {\r\n\t\treturn $object.hasKey(this._dictionary, key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the value for a specific key.\r\n\t *\r\n\t * @param key  The key to search for\r\n\t * @return Value for the key, or `undefined` if it doesn't exist\r\n\t */\r\n\tpublic getKey(key: Key): Optional<T> {\r\n\t\treturn this._dictionary[key];\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts value at specific key.\r\n\t *\r\n\t * Will thrown an exception if the key already exists in the dictionary.\r\n\t *\r\n\t * @param key    Key\r\n\t * @param value  Value\r\n\t */\r\n\tpublic insertKey(key: Key, value: T): void {\r\n\t\tif ($object.hasKey(this._dictionary, key)) {\r\n\t\t\tthrow new Error(\"Key \" + key + \" already exists in dictionary\");\r\n\r\n\t\t} else {\r\n\t\t\tthis._dictionary[key] = value;\r\n\r\n\t\t\tif (this.events.isEnabled(\"insertKey\")) {\r\n\t\t\t\tthis.events.dispatchImmediately(\"insertKey\", {\r\n\t\t\t\t\ttype: \"insertKey\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tkey: key,\r\n\t\t\t\t\tnewValue: value\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds or updates key/value into dictionary.\r\n\t *\r\n\t * If the key already exists, the old value will be overwritten.\r\n\t *\r\n\t * If the new value is exactly the same as the old value (using ===), it won't do anything.\r\n\t *\r\n\t * @param key    Key\r\n\t * @param value  Value\r\n\t */\r\n\tpublic setKey(key: Key, value: T): void {\r\n\t\tif ($object.hasKey(this._dictionary, key)) {\r\n\t\t\tconst oldValue = this._dictionary[key];\r\n\r\n\t\t\tif (oldValue !== value) {\r\n\t\t\t\tthis._dictionary[key] = value;\r\n\r\n\t\t\t\tif (this.events.isEnabled(\"setKey\")) {\r\n\t\t\t\t\tthis.events.dispatchImmediately(\"setKey\", {\r\n\t\t\t\t\t\ttype: \"setKey\",\r\n\t\t\t\t\t\ttarget: this,\r\n\t\t\t\t\t\tkey: key,\r\n\t\t\t\t\t\toldValue: oldValue,\r\n\t\t\t\t\t\tnewValue: value\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.events.isEnabled(\"removed\")) {\r\n\t\t\t\t\tthis.events.dispatchImmediately(\"removed\", {\r\n\t\t\t\t\t\ttype: \"removed\",\r\n\t\t\t\t\t\ttarget: this,\r\n\t\t\t\t\t\toldValue: oldValue\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tthis._dictionary[key] = value;\r\n\r\n\t\t\tif (this.events.isEnabled(\"insertKey\")) {\r\n\t\t\t\tthis.events.dispatchImmediately(\"insertKey\", {\r\n\t\t\t\t\ttype: \"insertKey\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tkey: key,\r\n\t\t\t\t\tnewValue: value\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates the value at specific `key` using custom function.\r\n\t *\r\n\t * Passes in current value into the function, and uses its output as a new\r\n\t * value.\r\n\t *\r\n\t * If the new value is exactly the same as the old value (using ===), it won't do anything.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param key  Key\r\n\t * @param fn   Function to transform the value\r\n\t */\r\n\tpublic updateKey(key: Key, fn: (value: T) => T): void {\r\n\t\tif ($object.hasKey(this._dictionary, key)) {\r\n\t\t\tconst oldValue = this._dictionary[key];\r\n\t\t\tconst newValue = fn(oldValue);\r\n\r\n\t\t\tif (oldValue !== newValue) {\r\n\t\t\t\tthis._dictionary[key] = newValue;\r\n\r\n\t\t\t\tif (this.events.isEnabled(\"setKey\")) {\r\n\t\t\t\t\tthis.events.dispatchImmediately(\"setKey\", {\r\n\t\t\t\t\t\ttype: \"setKey\",\r\n\t\t\t\t\t\ttarget: this,\r\n\t\t\t\t\t\tkey: key,\r\n\t\t\t\t\t\toldValue: oldValue,\r\n\t\t\t\t\t\tnewValue: newValue\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.events.isEnabled(\"removed\")) {\r\n\t\t\t\t\tthis.events.dispatchImmediately(\"removed\", {\r\n\t\t\t\t\t\ttype: \"removed\",\r\n\t\t\t\t\t\ttarget: this,\r\n\t\t\t\t\t\toldValue: oldValue\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Key \" + key + \" doesn't exist in dictionary\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Removes value at specific `key` from dictionary.\r\n\t *\r\n\t * @param key  Key to remove\r\n\t */\r\n\tpublic removeKey(key: Key): void {\r\n\t\tif ($object.hasKey(this._dictionary, key)) {\r\n\t\t\tconst oldValue = this._dictionary[key];\r\n\r\n\t\t\tdelete this._dictionary[key];\r\n\r\n\t\t\tif (this.events.isEnabled(\"removeKey\")) {\r\n\t\t\t\tthis.events.dispatchImmediately(\"removeKey\", {\r\n\t\t\t\t\ttype: \"removeKey\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tkey: key,\r\n\t\t\t\t\toldValue: oldValue\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (this.events.isEnabled(\"removed\")) {\r\n\t\t\t\tthis.events.dispatchImmediately(\"removed\", {\r\n\t\t\t\t\ttype: \"removed\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\toldValue: oldValue\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [insertKeyIfEmpty description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo description\r\n\t * @param key      [description]\r\n\t * @param ifEmpty  [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic insertKeyIfEmpty(key: Key, ifEmpty: () => T): T {\r\n\t\tif (!this.hasKey(key)) {\r\n\t\t\tthis.insertKey(key, ifEmpty());\r\n\t\t}\r\n\r\n\t\treturn <T>this.getKey(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes all items from the dictionary.\r\n\t */\r\n\tpublic clear(): void {\r\n\t\t// TODO dispatch this after clear\r\n\t\tif (this.events.isEnabled(\"removed\")) {\r\n\t\t\t$object.each(this._dictionary, (key, value) => {\r\n\t\t\t\tthis.events.dispatchImmediately(\"removed\", {\r\n\t\t\t\t\ttype: \"removed\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\toldValue: value\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis._dictionary = {};\r\n\r\n\t\tif (this.events.isEnabled(\"cleared\")) {\r\n\t\t\tthis.events.dispatchImmediately(\"cleared\", {\r\n\t\t\t\ttype: \"cleared\",\r\n\t\t\t\ttarget: this\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Copies items from another Dictionary.\r\n\t *\r\n\t * @param source  A Dictionary to copy items from\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\t$iter.each(source.iterator(), (a) => {\r\n\t\t\t// TODO fix this type cast\r\n\t\t\tthis.setKey(<Key>a[0], a[1]);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an interator that can be used to iterate through all items in\r\n\t * the dictionary.\r\n\t *\r\n\t * @return Iterator\r\n\t */\r\n\tpublic iterator(): $iter.Iterator<[Key, T]> {\r\n\t\t// @todo fix this type after the Iterator bug is fixed\r\n\t\t// https://github.com/Microsoft/TypeScript/issues/16730\r\n\t\treturn <$iter.Iterator<[Key, T]>>$object.entries(this._dictionary);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an ES6 iterator for the keys/values of the dictionary.\r\n\t */\r\n\tpublic *[Symbol.iterator](): Iterator<[Key, T]> {\r\n\t\t// TODO make this more efficient ?\r\n\t\tfor (let key in this._dictionary) {\r\n\t\t\tif ($object.hasKey(this._dictionary, key)) {\r\n\t\t\t\tyield [<Key>key, this._dictionary[key]];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Calls `f` for each key/value in the dictionary.\r\n\t */\r\n\tpublic each(f: (key: Key, value: T) => void): void {\r\n\t\t$iter.each(this.iterator(), ([key, value]) => f(key, value));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an iterator that can be used to iterate through all items in\r\n\t * the dictionary, ordered by key.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Iterator\r\n\t */\r\n\tpublic sortedIterator(): $iter.Iterator<[Key, T]> {\r\n\t\treturn $iter.sort(this.iterator(), (x, y) => $string.order(x[0], y[0]));\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * A version of a [[Dictionary]] that has a \"template\".\r\n *\r\n * A template is an instance of an object, that can be used to create new\r\n * elements in the list without actually needing to create instances for those.\r\n *\r\n * When new element is created in the list, e.g. by calling its `create()`\r\n * method, an exact copy of the element is created (including properties and\r\n * other attributes), inserted into the list and returned.\r\n */\r\nexport class DictionaryTemplate<Key extends string, T extends IClone<T> & { isTemplate: boolean }> extends Dictionary<Key, T> {\r\n\t/**\r\n\t * A template object.\r\n\t *\r\n\t * @todo Make this private\r\n\t */\r\n\tpublic _template!: T;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t *\r\n\t * @param t Template object\r\n\t */\r\n\tpublic constructor(t: T) {\r\n\t\tsuper();\r\n\t\tthis.template = t;\r\n\t}\r\n\r\n\t/**\r\n\t * A \"template\" object to copy all properties from when creating new list\r\n\t * items.\r\n\t *\r\n\t * @param v  Template object\r\n\t */\r\n\tpublic set template(v: T) {\r\n\t\tv.isTemplate = true;\r\n\t\tthis._template = v;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Template object\r\n\t */\r\n\tpublic get template(): T {\r\n\t\treturn this._template;\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all elements from other dictionary.\r\n\t *\r\n\t * @param source  Source dictionary\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\t$iter.each(source.iterator(), (a) => {\r\n\t\t\t// TODO fix this type cast\r\n\t\t\t// TODO why does this need to clone ?\r\n\t\t\tthis.setKey(<Key>a[0], a[1].clone());\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Instantiates a new object of the specified type, adds it to specified\r\n\t * `key` in the dictionary, and returns it.\r\n\t *\r\n\t * @param make  Item type to use. Will use the default type for the dictionary if not specified.\r\n\t * @return      Newly created item\r\n\t */\r\n\tpublic create(key: Key): T {\r\n\t\treturn this.insertKeyIfEmpty(key, () => this.template.clone());\r\n\t}\r\n\r\n}\r\n"],"sourceRoot":""}